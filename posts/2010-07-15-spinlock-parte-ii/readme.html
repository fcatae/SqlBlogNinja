<a link='https://blogs.msdn.microsoft.com/fcatae/2010/07/15/spinlock-parte-ii/'>Spinlock (Parte II)</a>
<p>No <a href="http://blogs.msdn.com/b/fcatae/archive/2010/07/12/spinlock-parte-1.aspx" target="_blank">post anterior</a>, fiquei um pouco receoso sobre meu comentário falando de spinlock usando T-SQL. A razão disso é que SPINLOCK não tem nada a ver com linguagens de alto nível, porém, está diretamente relacionado com a arquitetura de processador e códigos em assembly. Por isso, a melhor referência são os fabricantes de processadores, como a Intel e AMD.</p>  <p>Há um exemplo bastante simples no manual da Intel:</p>  <p><a title="http://www.intel.com/Assets/PDF/manual/248966.pdf" href="http://www.intel.com/Assets/PDF/manual/248966.pdf">http://www.intel.com/Assets/PDF/manual/248966.pdf</a></p>  <blockquote>   <p><em><font face="Courier New">Spin_Lock:          <br />&#160;&#160;&#160; CMP lockvar, 0 ; // Check if lock is free.           <br />&#160;&#160;&#160; JE Get_lock           <br />&#160;&#160;&#160; PAUSE; // Short delay.           <br />&#160;&#160;&#160; JMP Spin_Lock;           <br /><font color="#ff0000">Get_Lock:            <br />&#160;&#160;&#160; MOV EAX, 1;             <br />&#160;&#160;&#160; XCHG EAX, lockvar; // Try to get lock.             <br />&#160;&#160;&#160; CMP EAX, 0; // Test if successful.             <br />&#160;&#160;&#160; JNE Spin_Lock;</font>           <br />Critical_Section:           <br />&#160;&#160;&#160; &lt;critical section code&gt;           <br />MOV lockvar, 0; // Release lock.</font></em></p> </blockquote>  <p>O trecho Get_Lock (em vermelho) corresponde a um loop infinito implementado usando apenas 4 instruções assembly. Normalmente, assume-se que o spinlock apresentará um baixo número de colisões e poucos spins. </p>  <p>Vamos supor que para cada tentativa de obter um spinlock haja uma média de 10 spins e que correspondem a 80 ciclos de CPU. </p>  <p>Qual é a alternativa ao spinlock? O sistema operacional disponibiliza os objetos de Eventos, Mutex, Semáforos, etc. Ao usar esses objetos, gastam-se pelo menos 200 ciclos de CPU para fazer a transição com a Kernel e ainda há a possibilidade de ocorrer um Context Switch na Thread.</p>  <p>Aqui vem a questão: o que é melhor usar, um spinlock ou uma primitiva do sistema operacional? A resposta é <u>depende</u>. Em geral, o spinlock apresenta uma performance melhor do que os objetos de eventos e mutex. Por outro lado, há casos no qual o spinlock apresenta um número muito alto de colisões e spins, que degrada sua performance.</p>  <p>O fato é que o controle de Spinlock não está nas mãos do DBA e sim, na arquitetura do produto. Por outro lado, podemos sempre realizar uma monitoração periódica dos spinlocks usando o comando DBCC SQLPERF(SPINLOCKSTATS) para detectar problemas e gargalos do SQL, com o intuito de tentar contorná-los.</p>  <p>Há ainda mais um post sobre o assunto de spinlocks. </p>  <p>Enquanto isso, gostaria de adiantar algo: Você já ouviu falar de WAITSTATS? Há uma estrutura denominada LATCH e ela corresponde às primitivas do Sistema Operacional (Eventos, Semáforos e Mutex).</p>
