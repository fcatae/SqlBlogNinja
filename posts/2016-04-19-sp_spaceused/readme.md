<a link='https://blogs.msdn.microsoft.com/fcatae/2016/04/19/sp_spaceused/'>sp_spaceused</a>
<p>Continuando a s&eacute;rie dos comandos hist&oacute;ricos, vou apresentar o comando <strong>sp_spaceused</strong>. Embora esse seja um comando antigo, essa &eacute; uma das procedures que mais uso no dia a dia.<p>Nos posts anteriores comentei sobre <a href="http://blogs.msdn.com/b/fcatae/archive/2016/03/22/set-statistics-io.aspx">a import&acirc;ncia do SET STATISTICS IO</a> e do <a href="http://blogs.msdn.com/b/fcatae/archive/2016/03/29/dbcc-dropcleanbuffers.aspx">uso correto do DBCC DROPCLEANBUFFERS</a>. Comentei sobre o <a href="http://blogs.msdn.com/b/fcatae/archive/2016/04/05/dbcc-showcontig.aspx">DBCC SHOWCONTIG para visualizar a fragmenta&ccedil;&atilde;o</a> e <a href="http://blogs.msdn.com/b/fcatae/archive/2016/04/12/dbcc-page.aspx">o famoso DBCC PAGE em a&ccedil;&atilde;o</a>. &Eacute; uma saga de otimiza&ccedil;&atilde;o ao contr&aacute;rio!</p><p>Nesse post vamos fazer uma m&aacute;gica! Sim, vou mostrar uma query que &eacute; um tanto lenta&hellip; talvez voc&ecirc; a conhe&ccedil;a:</p><blockquote>   <p><strong>SELECT * FROM produtos WHERE id = 1234</strong></p> </blockquote><p>Dessa vez ela conseguiu bater o recorde de lentid&atilde;o e sem uma explica&ccedil;&atilde;o aparente! E cuidado porque essa &ldquo;m&aacute;gica&rdquo; pode estar ocorrendo no seu ambiente SQL.</p><h3>Hora do Show!</h3><p>Eu tenho uma tabela vazia chamada &ldquo;produtos&rdquo;. Se voc&ecirc; leu os artigos anteriores, ent&atilde;o deve conhecer bem. Ela &eacute; simples, tem dois campos e nenhum &iacute;ndice. </p><blockquote>   <p><a href="images\4572.image_15FFF646.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;margin: 0px;padding-right: 0px" border="0" alt="image" src="images\2437.image_thumb_3F0A9542.png" width="198" height="103"></a></p> </blockquote><p>Para garantir que n&atilde;o h&aacute; registro na tabela, vou rodar o comando DELETE sem nenhuma condi&ccedil;&atilde;o WHERE. Isso &eacute; para garantir que qualquer informa&ccedil;&atilde;o seja eliminada antes de come&ccedil;ar o truque.</p><blockquote>   <p><a href="images\3630.image_656C788D.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\0285.image_thumb_35B160BF.png" width="138" height="36"></a></p> </blockquote><p>Deixo mostrar que a tabela est&aacute; completamente vazia (sa&iacute;da no modo texto):</p><blockquote>   <p><a href="images\3554.image_750F144F.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\1616.image_thumb_507D86CB.png" width="293" height="118"></a></p> </blockquote><p>Vou inserir um &uacute;nico registro e vou colocar um nome aleat&oacute;rio baseado na fun&ccedil;&atilde;o NEWID.</p><blockquote>   <p><a href="images\8713.image_72D51C44.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\5531.image_thumb_673F5F05.png" width="317" height="69"></a></p> </blockquote><p>Preparem-se para o grande momento! Vamos limpar a mem&oacute;ria usando o DBCC DROPCLEANBUFFER&hellip;</p><blockquote>   <p><a href="images\1781.image_5BA9A1C6.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\6052.image_thumb_690FB4CC.png" width="178" height="27"></a></p> </blockquote><p>E rodamos a consulta!</p><blockquote>   <p><a href="images\7563.image_0B674A46.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\6332.image_thumb_3F9B738C.png" width="499" height="221"></a></p> </blockquote><p>A consulta de uma tabela com um &uacute;nico registro demorou 3 segundos. Vou repetir essa &uacute;ltima execu&ccedil;&atilde;o com a sa&iacute;da dos resultados do SET STATISTICS TIME E SET STATISTICS IO.</p><blockquote>   <p><a href="images\7534.image_1627324C.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\0181.image_thumb_0A91750D.png" width="189" height="66"></a></p> </blockquote><p><a href="images\4846.image_7EFBB7CD.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\3414.image_thumb_52DEBADC.png" width="718" height="401"></a></p><p>Mas eu juro que a tabela s&oacute; tem um registro!</p><p>&nbsp;</p><h3>Revelando o Truque</h3><p>A parte principal da m&aacute;gica &eacute; a prepara&ccedil;&atilde;o da tabela &ldquo;produtos&rdquo;, pois &eacute; ela quem causa o alto tempo de execu&ccedil;&atilde;o. </p><p><strong>Passo 1: Criar a tabela &ldquo;produtos&rdquo; &ndash; </strong>Criamos uma tabela usando os campos [id] e [nome]. Usamos o tipo CHAR para aumentar o n&uacute;mero de p&aacute;ginas da tabela sem precisar adicionar uma quantidade muito grande de registros. Entretanto, qualquer tipo de dado poderia ser usado. A &uacute;nica restri&ccedil;&atilde;o &eacute; n&atilde;o criar &iacute;ndices ou colunas com chaves prim&aacute;rias.</p><blockquote>   <p><a href="images\5773.image_25EE7963.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\5001.image_thumb_48460EDC.png" width="198" height="103"></a></p> </blockquote><p>Nesse primeiro momento, a tabela est&aacute; realmente vazia: </p><blockquote>   <p><a href="images\4150.image_55AC21E2.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\8171.image_thumb_29FB57E6.png" width="360" height="121"></a></p> </blockquote><p>&nbsp;</p><p><strong>Passo 2: Populamos a tabela com registros &ndash; </strong>O n&uacute;mero de registros n&atilde;o &eacute; importante. A tabela deve ocupar um grande n&uacute;mero de p&aacute;ginas em disco. A forma mais r&aacute;pida de popular uma tabela &eacute; usando INSERT SELECT, que insere um n&uacute;mero exponencial de registros.</p><blockquote>   <p><a href="images\3438.image_0C1CD3E5.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\3731.image_thumb_4050FD2B.png" width="385" height="272"></a></p> </blockquote><p>Ao final do passo 2, a tabela estar&aacute; ocupando 30MB. Se voc&ecirc; quiser criar impacto, pode continuar adicionando registros at&eacute; chegar na casa dos GB.</p><blockquote>   <p><a href="images\7266.image_505FCBE2.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\6406.image_thumb_76C1AF2D.png" width="378" height="126"></a></p> </blockquote><p>&nbsp;</p><p><strong>Passo 3. O grande segredo &eacute; apagar registros sem desaloc&aacute;-los &ndash; </strong>Nas estruturas Heap, existem algumas condi&ccedil;&otilde;es necess&aacute;rias para que as p&aacute;ginas sejam desalocadas durante o processo de remo&ccedil;&atilde;o de registro. Isso significa que os registros ser&atilde;o apagados, mas a tabela continua ocupando espa&ccedil;o. </p><p>O espa&ccedil;o em disco &eacute; desalocado nas seguintes condi&ccedil;&otilde;es:</p><ol>   <li>Truncate Table</li>    <li>DELETE WITH (TABLOCK)</li>    <li>DELETE com Lock Escalation para TABLOCK</li>    <li>ALTER TABLE &hellip; REBUILD</li>    <li>CREATE CLUSTERED INDEX</li> </ol><p>Podemos apagar os registros usando <strong>DELETE TOP(n) WITH (PAGLOCK)</strong>.</p><blockquote>   <p><a href="images\8203.image_3FE75AE7.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;margin: 0px;padding-right: 0px" border="0" alt="image" src="images\7433.image_thumb_4FF6299E.png" width="323" height="133"></a></p> </blockquote><p>Dessa forma, evitamos a possibilidade de ocorrer um Lock Escalation durante a remo&ccedil;&atilde;o de registros.</p><blockquote>   <p><a href="images\2604.image_042A52E5.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\8053.image_thumb_33E7FB64.png" width="372" height="119"></a></p> </blockquote><p>No final, nossa tabela est&aacute; pronta! Possui 30MB de espa&ccedil;o alocado e nenhum registro. </p><p><strong>Passo 4: Preparativos finais </strong>&ndash; Podemos deixar o efeito mais vis&iacute;vel com as seguintes a&ccedil;&otilde;es:</p><ul>   <li>Habilitar o Trace Flag Global 652 para desligar as opera&ccedil;&otilde;es de read-ahead</li>    <li>Limpeza da Buffer Pool usando o CHECKPOINT + DBCC DROPCLEANBUFFERS</li> </ul><p>Como a tabela n&atilde;o possui registro, ent&atilde;o podemos realizar opera&ccedil;&otilde;es de DELETE sem o risco de Lock Escalation. Pronto!</p><p>&nbsp;</p><h3>Conclus&atilde;o</h3><p>Esse &eacute; um problema muito comum das HEAPS e o diagn&oacute;stico n&atilde;o &eacute; trivial. Muitas pessoas realizam a desfragmenta&ccedil;&atilde;o de &iacute;ndice, mas n&atilde;o incluem rotinas para desfragmentar tabelas sem &iacute;ndice clustered. Como recomenda&ccedil;&atilde;o geral, todas as tabelas deveriam ter &iacute;ndice clustered.</p><p>No pr&oacute;ximo post, vou falar sobre a estrutude do &iacute;ndice.</p></p>

