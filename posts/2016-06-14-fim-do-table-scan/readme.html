<a link='https://blogs.msdn.microsoft.com/fcatae/2016/06/14/fim-do-table-scan/'>Fim do Table Scan</a>
<p>Acabei de terminar uma série de artigos falando sobre Table Scan e agora vou dizer que não existe futuro para o Table Scan (IAM Scan).</p> <ul> <li><strong>A importância de medir I/O e o cuidado com o Cache em memória</strong>  <ul> <li>Parte 1: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/03/22/set-statistics-io.aspx">SET STATISTICS IO</a>  <li>Parte 2: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/03/29/dbcc-dropcleanbuffers.aspx">DBCC DROPCLEANBUFFERS</a> </li></ul> <li><strong>Estrutura Heap e sua fragmentação</strong>  <ul> <li>Parte 3: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/04/05/dbcc-showcontig.aspx">DBCC SHOWCONTIG</a>  <li>Parte 4: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/04/12/dbcc-page.aspx">DBCC PAGE</a>  <li>Parte 5: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/04/19/sp-spaceused.aspx">sp_spaceused</a> </li></ul> <li><strong>Estrutura B-Tree e sua fragmentação</strong>  <ul> <li>Parte 6: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/04/26/dbcc-ind.aspx">DBCC IND</a>  <li>Parte 7: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/05/03/dbcc-indexdefrag.aspx">DBCC INDEXDEFRAG</a>  <li>Parte 8: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/05/10/dbcc-dbreindex.aspx">DBCC DBREINDEX</a> </li></ul> <li><strong>Impacto da fragmentação</strong>  <ul> <li>Parte 9: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/05/17/sp-detach-db.aspx">sp_detach_db</a></li></ul> <li><strong>Por que Table Scan quando um índice resolve?</strong>  <ul> <li>Parte 10: <a href="https://blogs.msdn.microsoft.com/fcatae/2016/05/24/set-showplan_text/">SET SHOWPLAN_TEXT</a></li></ul></li></ul> <p>&nbsp;</p> <p>O motivo de dizer isso é apresentar a Regra Ninja de Performance #2:</p> <p><a href="https://msdnshared.blob.core.windows.net/media/2016/05/image881.png"><img title="image" style="border-left-width: 0px;border-right-width: 0px;border-bottom-width: 0px;padding-top: 0px;padding-left: 0px;padding-right: 0px;border-top-width: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/2016/05/image_thumb735.png" width="768" height="173"></a></p> <p>A regra é bem simples: se você quer desempenho, então precisa organizar o recurso da forma adequada. Em um banco de dados transacional (OLTP), todas as consultas devem ser feitas através de índice. Não faz sentido acessar os dados através de Table Scan. Em ambiente de Data Warehousing e OLAP, as informações devem ser guardadas em um formato Columnar, que são obtidos usando os índices ColumnStore.</p> <p>Claro que existem exceções, como por exemplo, tabelas temporárias ou staging podem economizar tempo de processamento usando Heaps simples.</p> <p>&nbsp;</p> <h4>Por que nunca alguém me disse isso antes? (Ou pelo menos, não com essas palavras)</h4> <p>Meu palpite: os índices ColumnStore se tornaram viáveis a partir do SQL 2016, quando é possível realizar operações DML e criar índices BTree sobre as tabelas com índices ColumnStore.</p> <p>&nbsp;</p> <h4>Fim do Table Scan</h4> <p>O correto seria dizer o fim do IAM Scan. No próximo artigo, vou mostrar que o BTree Scan (Index Scan) ainda continua vivo por conta da estratégia de Covering Index.</p>
