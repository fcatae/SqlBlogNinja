<a link='https://blogs.msdn.microsoft.com/fcatae/2016/08/02/otimizando-delete-top-1000/'>Otimizando DELETE TOP 1000</a>
<p>No último post, comentei do <a href="https://blogs.msdn.microsoft.com/fcatae/2016/07/19/desafio-delete-1000-linhas/">desafio do DELETE de 1000 linhas</a>, que consistia em resolver um problema bastante comum:</p> <blockquote> <p><strong>Problema: </strong>Apagar os 1000 registros mais antigos da tabela.</p></blockquote> <p>A fim de tornar a situação mais real, criei uma tabela e inseri 1 milhão de registros.</p> <p><a href="images\image385.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\image_thumb279.png" width="482" height="233"></a></p> <p>Frequentemente, vejo que os programadores executam o seguinte SELECT para eliminar as linhas:</p> <p><a href="images\image386.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\image_thumb280.png" width="505" height="76"></a></p> <p>Existe uma incoerência nesse comando, que fica visível ao expor o plano de execução.</p> <p><a href="images\image387.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\image_thumb281.png" width="819" height="130"></a></p> <p>Note que estamos acessando a tabela DUAS vezes e, em ambas ocasiões, são leituras para identificar quais os registros que devem ser apagados. O ideal seria minimizar o acesso à tabela durante o comando de DELETE. </p> <p>Rodando a consulta o resultado não foi ruim: apenas 374 milissegundos de execução.</p> <p>&nbsp;</p> <h3>Resolvendo o problema</h3> <p>Antes de mostrar a solução, vamos começar com um problema mais simples:</p> <blockquote> <p><strong>Problema: </strong>Identificar os 1000 registros mais antigos da tabela</p></blockquote> <p>Assim, temos o comando e seu plano de execução:</p> <p><a href="images\image388.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\image_thumb282.png" width="508" height="180"></a></p> <p>Note que, fazemos um único Table Scan na tabela de Logs (bom sinal). Criamos uma VIEW para essa visualização:</p> <p><a href="images\image389.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\image_thumb283.png" width="483" height="77"></a></p> <p>Acredite se quiser, mas a solução é tão simples quanto um DELETE sem WHERE.</p> <p><a href="images\image390.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\image_thumb284.png" width="240" height="54"></a></p> <p>O plano de execução é semelhante ao SELECT:</p> <p><a href="images\image391.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\image_thumb285.png" width="594" height="76"></a></p> <p>O passo final é criar um índice para suportar a consulta. No caso, podemos evitar a operação de Sort (responsável por 88% do custo) através de um índice clustered sobre a coluna “dtHorario”. </p> <p><a href="images\image392.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\image_thumb286.png" width="416" height="54"></a></p> <p>O plano de execução agora ficou perfeito: uma única leitura na tabela, não há operação de HASH ou SORT, sem paralelismo.</p> <p><a href="images\image393.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\image_thumb287.png" width="610" height="214"></a></p> <p>&nbsp;</p> <h3>Comparação</h3> <p>Como ficou o tempo após a otimização? Usando os comandos SET STATISTICS TIME e SET STATISTICS IO, observamos o seguinte resultado: remover os 1000 registros forçou um scan completo na tabela tbLogs, gerou uma tabela temporária para SORT e consumiu 1812ms de CPU. Graças ao paralelismo de execução, foi possível concluir o comando em apenas 374ms.</p> <p><a href="images\image394.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;margin: 0px;padding-right: 0px" border="0" alt="image" src="images\image_thumb288.png" width="448" height="153"></a></p> <p>Por outro lado, após criar o índice clustered e reescrever a consulta, temos o seguinte resultado:</p> <p><a href="images\image395.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\image_thumb289.png" width="493" height="129"></a></p> <p>Antes de concluir, precisamos falar sobre o custo das queries.</p> <p><strong>ANTES:</strong></p> <p><a href="images\image396.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;margin: 0px;padding-right: 0px" border="0" alt="image" src="images\image_thumb290.png" width="244" height="231"></a></p> <p><strong>DEPOIS:</strong></p> <p><a href="images\image397.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;margin: 0px;padding-right: 0px" border="0" alt="image" src="images\image_thumb291.png" width="244" height="158"></a></p> <p>&nbsp;</p> <h3>Conclusão</h3> <p>A criação do índice certo é fundamental para garantir um bom desempenho de banco de dados. Entretanto, em muitos casos, observam-se construções INCORRETAS e que devem ser reescritas. Nesse artigo, demonstrei um dos erros mais comuns encontrados nos sistemas: acessar a tabela duas vezes. </p> <p>A forma mais fácil de resolver esse tipo de problema é usar Views ou CTE. Nesse problema poderia ter reescrito a query da seguinte forma:</p> <p><a href="images\image398.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\image_thumb292.png" width="498" height="138"></a></p> <p>No próximo artigo, vamos fazer um outro desafio. Não perca! </p>
