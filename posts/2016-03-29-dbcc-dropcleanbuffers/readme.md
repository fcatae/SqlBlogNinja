<a link='https://blogs.msdn.microsoft.com/fcatae/2016/03/29/dbcc-dropcleanbuffers/'>DBCC DROPCLEANBUFFERS</a>
<p>No artigo anterior, comentei sobre <a href="http://blogs.msdn.com/b/fcatae/archive/2016/03/22/set-statistics-io.aspx">a vantagem de usar o SET STATISTICS IO</a> como ferramenta de an&aacute;lise de performance. <p>Terminei o artigo o mist&eacute;rio: por que o n&uacute;mero de read-ahead e logical reads n&atilde;o bate?</p><p><a href="images\1055.image_600D1875.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\6378.image_thumb_0FCAC0F5.png" width="653" height="285"></a></p><p>O resultado esperado deveria ser:</p><p><a href="images\6102.image_231098F6.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\4274.image_thumb_053214F5.png" width="654" height="64"></a></p><p>&nbsp;</p><h3>Limpando o Buffer Bool</h3><p>O comando <strong>DBCC DROPCLEANBUFFERS </strong>remove as p&aacute;ginas do banco de dados do cache. Entretanto, o pr&oacute;prio nome j&aacute; diz: ele remove somente as p&aacute;ginas limpas e que s&atilde;o seguras para serem descartadas. As p&aacute;ginas que possuem modifica&ccedil;&atilde;o s&atilde;o chamadas de suja e n&atilde;o podem ser descartadas enquanto n&atilde;o forem gravadas em disco. Essa explica&ccedil;&atilde;o est&aacute; na refer&ecirc;ncia do comando.</p><blockquote>   <p><strong>DBCC DROPCLEANBUFFERS</strong>      <br><a title="https://msdn.microsoft.com/en-us/library/ms187762.aspx" href="https://msdn.microsoft.com/en-us/library/ms187762.aspx">https://msdn.microsoft.com/en-us/library/ms187762.aspx</a></p> </blockquote><p>Podemos confirmar esse comportamento atrav&eacute;s das DMV sys.dm_os_buffer_descriptors:</p><p><a href="images\3250.image_550ACA31.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\4064.image_thumb_28EDCD40.png" width="708" height="290"></a></p><p>Esse comportamento muda ap&oacute;s rodar o CHECKPOINT manualmente:</p><p><a href="images\3146.image_7A96D843.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\6683.image_thumb_785CE038.png" width="644" height="202"></a></p><p>Depois rodar novamente o DBCC DROPCLEANBUFFERS.</p><p><a href="images\6646.image_60C532C5.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\7167.image_thumb_42E6AEC4.png" width="644" height="219"></a></p><p>&nbsp;</p><h3>Resultado</h3><p>O resultdo final foi que o n&uacute;mero de logical reads (1257) &eacute; igual a read-ahead pages (1257).</p><p><a href="images\4010.image_52894A86.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\1541.image_thumb_427D0C80.png" width="644" height="364"></a></p><p>Um fato interessante &eacute; que o tempo aumentou de 369ms para 852ms.</p><p>Parece que o banco de dados est&aacute; ficando mais lento. </p><p>&nbsp;</p><h3>Sempre &eacute; poss&iacute;vel piorar!</h3><p>Vamos desligar as opera&ccedil;&otilde;es de Read-Ahead no servidor inteiro usando o Trace Flag Global 652.</p><blockquote>   <p><a href="images\4810.image_43E12F52.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;margin: 0px;padding-right: 0px" border="0" alt="image" src="images\2287.image_thumb_5F198853.png" width="244" height="160"></a></p> </blockquote><p>Em seguida, limpamos o cache de dados e rodamos novamente a query.</p><p><a href="images\0066.image_1CA976CE.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="images\8080.image_thumb_49C0F44D.png" width="644" height="293"></a></p><p>Enquanto no artigo anterior a query rodava em 1ms, parece que batemos nosso recorde e chegamos a 1485ms.</p><p>&nbsp;</p><h3>Conclus&atilde;o</h3><p>Limpando o cache e desligando o comportamento de read-ahead afetou o desempenho da query sem mudar nenhum c&oacute;digo. Aproveito para avisar de alguns cuidados:</p><ul>   <li>N&atilde;o use DBCC DROPCLEANBUFFERS em produ&ccedil;&atilde;o.</li>    <li>Evite consultar a view sys.dm_os_buffer_descriptors</li>    <li>Jamais ligue o Trace Flag 652 em produ&ccedil;&atilde;o</li> </ul><p>No pr&oacute;ximo artigo, vamos explorar melhor o mecanismo de read-ahead e tentar uma forma de piorar (?) o desempenho de forma mais acentuada.</p></p>

