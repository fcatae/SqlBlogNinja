<a link='https://blogs.msdn.microsoft.com/fcatae/2010/10/13/problemas-com-nolock-sql-server/'>Problemas com NOLOCK (SQL Server)</a>
<p>Estava comentando sobre a <a href="http://blogs.msdn.com/b/fcatae/archive/2010/10/05/como-usar-select-with-nolock-para-melhorar-a-performance.aspx" target="_blank">recomendação indiscriminada do uso do NOLOCK</a>, mas até que ponto isso é bom ou ruim. Se a vantagem em performance é conhecida, quais seriam as desvantagens?</p>  <blockquote>   <p><strong>Links relacionados</strong></p>    <ul>     <li><a href="http://blogs.msdn.com/b/fcatae/archive/2010/10/05/como-usar-select-with-nolock-para-melhorar-a-performance.aspx">Como usar SELECT WITH NOLOCK para melhorar a Performance?</a> </li>      <li><a href="http://blogs.msdn.com/b/fcatae/archive/2010/10/06/nolock-ou-with-nolock-qual-a-sintaxe-correta.aspx">Qual a sintaxe correta: NOLOCK ou WITH (NOLOCK)?</a> </li>      <li><a href="http://blogs.msdn.com/b/fcatae/archive/2010/10/11/update-with-nolock-como-funciona.aspx">NOLOCK e INSERT/UPDATE/DELETE</a> </li>      <li><a href="http://blogs.msdn.com/b/fcatae/archive/2010/10/13/problemas-com-nolock-sql-server.aspx">Problemas com NOLOCK</a></li>      <li><a href="http://blogs.msdn.com/b/fcatae/archive/2010/04/28/efeitos-colaterais-do-with-nolock-parte-i.aspx">Efeitos colaterais do NOLOCK – Parte 1</a></li>      <li><a href="http://blogs.msdn.com/b/fcatae/archive/2010/06/02/efeitos-colaterais-do-with-nolock-parte-ii.aspx">Efeitos colaterais do NOLOCK – Parte 2</a></li>   </ul> </blockquote>  <p>O primeiro ponto é que <strong>NOLOCK </strong>funciona somente para as operações de <strong>LEITURA</strong> e nunca podem ser combinados com a escrita, exceto pelos casos descritos no post <a href="http://blogs.msdn.com/b/fcatae/archive/2010/10/11/update-with-nolock-como-funciona.aspx" target="_blank">NOLOCK e INSERT/UPDATE/DELETE</a>. </p>  <p>A grande desvantagem do uso de <strong>NOLOCK</strong> é o fato de permitir que o banco de dados realize uma <strong>LEITURA SUJA</strong>. O que seria a tal leitura suja? Vamos descrever por exemplos.</p>  <p>&#160;</p>  <h2>Exemplo 1</h2>  <p>Toda transação apresenta um comportamento atômico, ou seja, tudo ou nada. A transação abaixo remove os registros da tabela <strong>tbUsuarios</strong> e <strong>tbPedidos</strong> simultaneamente, na qual os registros são apagados de ambas as tabelas ou de nenhuma tabela. Não existe um estado transitório – no qual alguns registros ‘fabricio’ se encontram na tabela <strong>tbPedidos</strong>, mas já foram apagados de <strong>tbUsuarios</strong>. Isso se chama consistência de dados.</p> <font color="#0000ff" size="2" face="Courier New">   <blockquote>     <p align="left">BEGIN <font color="#0000ff" size="2" face="Courier New">TRANSACTION</font> </p>      <p align="left"></p>     <font color="#000000" size="2" face="Courier New"></font>      <p align="left"></p>     <font color="#0000ff" size="2" face="Courier New">&#160; DELETE</font><font color="#000000" size="2" face="Courier New"> tbUsuarios </font><font color="#0000ff" size="2" face="Courier New">WHERE</font><font color="#000000" size="2" face="Courier New"> nome </font><font color="#808080" size="2" face="Courier New">=</font><font color="#000000" size="2" face="Courier New"> </font><font color="#ff0000" size="2" face="Courier New">'fabricio'</font>       <p align="left"></p>     <font color="#000000" size="2" face="Courier New"></font><font color="#0000ff" size="2" face="Courier New">&#160; DELETE</font><font color="#000000" size="2" face="Courier New"> tbPedidos </font><font color="#0000ff" size="2" face="Courier New">WHERE</font><font color="#000000" size="2" face="Courier New"> usuario </font><font color="#808080" size="2" face="Courier New">=</font><font color="#000000" size="2" face="Courier New"> </font><font color="#ff0000" size="2" face="Courier New">'fabricio'</font>       <p align="left"></p>     <font color="#000000" size="2" face="Courier New"></font>      <p align="left"></p>     <font color="#0000ff" size="2" face="Courier New">COMMIT</font><font color="#000000" size="2" face="Courier New"> </font><font color="#0000ff" size="2" face="Courier New">TRANSACTION</font></blockquote> </font>  <p>A garantia de consistência de dados é realizada através dos bloqueios (LOCK), que são mantidos até a fase de COMMIT TRANSACTION. Somente após finalizar a transação, os LOCKs são liberados e a leitura é permitida. Isso corresponde a uma leitura consistente (READ COMMITTED). </p>  <p>Por outro lado, ao usar um comando com NOLOCK, estamos sinalizando ao SQL Server que utilize uma leitura suja (READ UNCOMMITTED). Essa leitura não espera pelo final da transação, ou seja, a leitura é observa todos os estados transitórios.</p>  <p>&#160;</p>  <h2>Exemplo 2</h2>  <p>Ainda pensando na consistência de dados usando transação, imagine a situação na qual temos a seguinte operação.</p> <font color="#0000ff" size="2" face="Courier New">   <blockquote>     <p align="left">BEGIN <font color="#0000ff" size="2" face="Courier New">TRANSACTION</font> </p>      <p align="left"></p>     <font color="#000000" size="2" face="Courier New"></font>      <p align="left"></p>     <font color="#008000" size="2" face="Courier New">&#160;&#160; -- Marca o registro como temporário</font>       <p align="left"></p>     <font color="#000000" size="2" face="Courier New"></font><font color="#0000ff" size="2" face="Courier New">&#160;&#160; UPDATE</font><font color="#000000" size="2" face="Courier New"> tbUsuarios </font><font color="#0000ff" size="2" face="Courier New">SET</font><font color="#000000" size="2" face="Courier New"> nome </font><font color="#808080" size="2" face="Courier New">=</font><font color="#000000" size="2" face="Courier New"> </font><font color="#ff0000" size="2" face="Courier New">'tmp'</font><font color="#000000" size="2" face="Courier New"> </font><font color="#0000ff" size="2" face="Courier New">WHERE</font><font color="#000000" size="2" face="Courier New"> nome </font><font color="#808080" size="2" face="Courier New">=</font><font color="#ff0000" size="2" face="Courier New"> <font color="#ff0000" size="2" face="Courier New">'fabricio'</font></font>       <p align="left"></p>     <font color="#000000" size="2" face="Courier New"></font>      <p align="left"></p>     <font color="#008000" size="2" face="Courier New">&#160;&#160; -- Defaz a operação</font>       <p align="left"></p>     <font color="#000000" size="2" face="Courier New"></font><font color="#0000ff" size="2" face="Courier New">&#160;&#160; UPDATE</font><font color="#000000" size="2" face="Courier New"> tbUsuarios </font><font color="#0000ff" size="2" face="Courier New">SET</font><font color="#000000" size="2" face="Courier New"> nome </font><font color="#808080" size="2" face="Courier New">= </font><font color="#ff0000" size="2" face="Courier New"><font color="#ff0000" size="2" face="Courier New">'fabricio'</font></font><font color="#000000" size="2" face="Courier New"> </font><font color="#0000ff" size="2" face="Courier New">WHERE</font><font color="#000000" size="2" face="Courier New"> nome </font><font color="#808080" size="2" face="Courier New">= </font><font color="#ff0000" size="2" face="Courier New"><font color="#ff0000" size="2" face="Courier New">'tmp'</font></font>       <p align="left"></p>     <font color="#000000" size="2" face="Courier New"></font>      <p align="left"></p>     <font color="#0000ff" size="2" face="Courier New">COMMIT</font><font color="#000000" size="2" face="Courier New"> </font><font color="#0000ff" size="2" face="Courier New">TRANSACTION</font></blockquote> </font>  <p align="left"><font color="#0000ff" size="2" face="Courier New"></font></p>  <p>A transação efetua a modificação de FABRICIO –&gt; TMP –&gt; FABRICIO, ou seja, não faz absolutamente nenhuma mudança comparando os estados inicial e final. Isso garante que o simples comando abaixo sempre retorne o nome correto.</p> <font color="#0000ff" size="2" face="Courier New">   <blockquote>     <p align="left">SELECT <font color="#808080" size="2" face="Courier New">*</font><font color="#000000" size="2" face="Courier New"> </font><font color="#0000ff" size="2" face="Courier New">FROM</font><font color="#000000" size="2" face="Courier New"> tbUsuarios</font></p>   </blockquote> </font>  <p>Se fosse utilizado o comando NOLOCK, existiria a remota possibilidade de observarmos os estados transitórios.</p> <font color="#0000ff" size="2" face="Courier New">   <blockquote>     <p align="left">SELECT <font color="#808080" size="2" face="Courier New">*</font><font color="#000000" size="2" face="Courier New"> </font><font color="#0000ff" size="2" face="Courier New">FROM</font><font color="#000000" size="2" face="Courier New"> tbUsuarios </font><font color="#0000ff" size="2" face="Courier New">WITH </font><font color="#808080" size="2" face="Courier New">(</font><font color="#0000ff" size="2" face="Courier New">NOLOCK</font><font color="#808080" size="2" face="Courier New">)</font></p>   </blockquote> </font>  <p>Nesse caso, a consulta poderia retornar o valor TMP. </p>  <p>&#160;</p>  <h2>Exemplo 3</h2>  <p>Nos exemplos 1 e 2, falamos exaustivamente sobre o comportamento do NOLOCK retornar informações transitórias. Esse exemplo 3 é um passo adiante, algo um pouco mais avançado, no qual a natureza transitória pode causar erros (!!!). O post <a href="http://blogs.msdn.com/b/fcatae/archive/2010/04/28/efeitos-colaterais-do-with-nolock-parte-i.aspx" target="_blank">Efeitos colaterais do NOLOCK – Parte 1</a> apresenta um script para mostrar um exemplo do erro 601.</p>  <blockquote>   <p><font color="#ff0000" size="2" face="Courier New">Msg 601, Level 12, State 3, Line 1        <br />Could not continue scan with NOLOCK due to data movement.</font>       <br /></p> </blockquote>  <p>O que aconteceu aqui foi exatamente o comportamento do exemplo 1 – enquanto o banco de dados efetuava o JOIN entre tabelas, o registro desapareceu de forma inesperada. Isso gerou o erro 601 de severidade 12. Uma forma de corrigir é utilizando bloqueios … ou melhor, evitando o uso de NOLOCK.</p>  <p>Apenas por curiosidade, vale a pena dar uma olhada em uma outra particularidade (não tão comum) do NOLOCK em <a href="http://blogs.msdn.com/b/fcatae/archive/2010/06/02/efeitos-colaterais-do-with-nolock-parte-ii.aspx" target="_blank">Efeitos colaterais do NOLOCK – Parte 2</a>.</p>  <p>&#160;</p>  <h2>Recomendação</h2>  <p>Sim, ainda recomendo que utilize NOLOCK para garantir performance no banco de dados. Mas não se esqueça das leituras sujas e dos erros transitórios.</p>  <p>A partir do SQL Server 2005, existe uma funcionalidade chamada READ COMMITTED SNAPSHOT. Esse recurso elimina (praticamente 100%) a necessidade de usar NOLOCK. A melhor parte é que não é necessário mudar o código da aplicação, basta ativá-lo na configuração do banco de dados.</p>
