<a link='https://blogs.msdn.microsoft.com/fcatae/2014/02/18/memory-leak-usando-openxml/'>Memory Leak usando OPENXML</a>
<p>Existem duas formas de acessar dados XML de dentro do SQL Server.</p>  <ul>   <li>Função OPENXML</li>    <li>Tipo nativo XML</li> </ul>  <p>Nesse post, falaremos sobre o uso do OPENXML – disponível desde o SQL Server 2000.</p>  <p>SQL Books Online apresenta um exemplo bastante simples:</p>  <blockquote>   <p>Examples: Using OPENXML      <br /><a title="http://technet.microsoft.com/en-us/library/ms187897.aspx" href="http://technet.microsoft.com/en-us/library/ms187897.aspx">http://technet.microsoft.com/en-us/library/ms187897.aspx</a></p> </blockquote>  <blockquote>   <p>DECLARE @DocHandle int      <br /> DECLARE @XmlDocument nvarchar(1000)       <br /> SET @XmlDocument = N'&lt;ROOT&gt;       <br />&lt; Customer CustomerID=&quot;VINET&quot; ContactName=&quot;Paul Henriot&quot;&gt;       <br />&#160;&#160; &lt;Order OrderID=&quot;10248&quot; CustomerID=&quot;VINET&quot; EmployeeID=&quot;5&quot;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; OrderDate=&quot;1996-07-04T00:00:00&quot;&gt;       <br />&#160;&#160;&#160;&#160;&#160; &lt; OrderDetail ProductID=&quot;11&quot; Quantity=&quot;12&quot;/&gt;       <br />&#160;&#160;&#160;&#160;&#160; &lt; OrderDetail ProductID=&quot;42&quot; Quantity=&quot;10&quot;/&gt;       <br />&#160;&#160; &lt;/Order&gt;       <br />&lt; /Customer&gt;       <br />&lt; Customer CustomerID=&quot;LILAS&quot; ContactName=&quot;Carlos Gonzlez&quot;&gt;       <br />&#160;&#160; &lt;Order OrderID=&quot;10283&quot; CustomerID=&quot;LILAS&quot; EmployeeID=&quot;3&quot;       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; OrderDate=&quot;1996-08-16T00:00:00&quot;&gt;       <br />&#160;&#160;&#160;&#160;&#160; &lt; OrderDetail ProductID=&quot;72&quot; Quantity=&quot;3&quot;/&gt;       <br />&#160;&#160; &lt;/Order&gt;       <br />&lt; /Customer&gt;       <br />&lt; /ROOT&gt;'       <br /> -- Create an internal representation of the XML document.       <br /> EXEC sp_xml_preparedocument @DocHandle OUTPUT, @XmlDocument       <br /> -- Execute a SELECT statement using OPENXML rowset provider.       <br /> SELECT *       <br /> FROM OPENXML (@DocHandle, '/ROOT/Customer',1)       <br />&#160;&#160;&#160;&#160;&#160; WITH (CustomerID&#160; varchar(10),       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ContactName varchar(20))       <br />EXEC sp_xml_removedocument @DocHandle</p> </blockquote>  <h2>Surpresa!</h2>  <p>Adivinhe o que acontece quando esquecemos de chamar a procedure <strong>sp_xml_<u>remove</u>document</strong>. </p>  <blockquote>   <p><font color="#ff0000">Msg 6624, Level 16, State 7, Procedure sp_xml_preparedocument, Line 1        <br /> XML document could not be created because server memory is low. Use sp_xml_removedocument to release XML documents.</font></p> </blockquote>  <p>Criamos uma situação de memory leak, na qual a memória fica lotada com documentos XML. Por segurança, esse consumo é limitado em 1/8 da memória total da instância SQL Server.</p>  <p>Normalmente essa situação ocorre em stored procedures que utilizam o OPENXML, mas deixam de remover a referência ao documento. A causa “óbvia” é que o desenvolvedor esqueceu. Mas existem outras condições que causam esse comportamento, como um Command Timeout antes de finalizar a execução da procedure. </p>  <p>Resolver esse problema é fácil: basta matar a sessão com referências XML. A parte difícil é identificar qual a sessão.</p>  <p>Minha sugestão é procurar as sessões usuárias que estejam inativas (sleeping).</p>  <blockquote>   <p><strong>select session_id, memory_usage from sys.dm_exec_sessions        <br /> where status = 'sleeping' and is_user_process = 1</strong></p> </blockquote>  <blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/2538.image_22AA8135.png"><img title="image" style="margin: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/4213.image_thumb_5D91B3FE.png" width="191" height="84" /></a></p> </blockquote>  <p>Nesse exemplo, poderia suspeitar da sessão 56 – que possui 3080 páginas de 8Kb alocadas (24MB). KILL nele!</p>  <p>Ao matar o processo 56, todos os recursos XML associados são automaticamente devolvidos ao gerenciador de memória. </p>  <p>A correção final é identificar as stored procedures que preparam o documento (sp_xml_preparedocument), mas esquecem de liberar o documento (sp_xml_removedocument).</p>  <p>Comentário: Aparentemente, a sessão 56 consumiu 3080 páginas de 8kb = 24MB. Essa informação está IMPRECISA! No próximo post vou explicar como identificar memory leak.</p>
