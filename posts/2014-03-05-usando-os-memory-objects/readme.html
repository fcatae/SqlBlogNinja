<a link='https://blogs.msdn.microsoft.com/fcatae/2014/03/05/usando-os-memory-objects/'>Usando os Memory Objects</a>
<p>Tudo começou com a discussão de XML. </p>  <blockquote>   <p>Memory Leak usando OPENXML     <br /><a title="http://blogs.msdn.com/b/fcatae/archive/2014/02/18/sp-xml-preparedocument-leak.aspx" href="http://blogs.msdn.com/b/fcatae/archive/2014/02/18/sp-xml-preparedocument-leak.aspx">http://blogs.msdn.com/b/fcatae/archive/2014/02/18/sp-xml-preparedocument-leak.aspx</a></p> </blockquote>  <p>Existem duas procedures:</p>  <ul>   <li>sp_xml_preparedocument</li>    <li>sp_xml_removedocument </li> </ul>  <p>A primeira serve para reservar a memória para o documento, enquanto que a segunda libera o recurso. Existe uma forma de causar um Memory Leak chamando várias vezes a procedure de “prepare” e esquecendo de liberar a memória com “remove”. </p>  <p>Em todos os problemas de alto consumo de memória, recomendo que utilize a <strong>monitoração de Memory Clerk</strong>.</p>  <blockquote>   <p>Monitorando Memória com os Clerks     <br /><a title="http://blogs.msdn.com/b/fcatae/archive/2014/02/25/monitorando-memoria.aspx" href="http://blogs.msdn.com/b/fcatae/archive/2014/02/25/monitorando-memoria.aspx">http://blogs.msdn.com/b/fcatae/archive/2014/02/25/monitorando-memoria.aspx</a></p> </blockquote>  <p>Se mesmo assim não for possível descobrir, podemos acompanhar o consumo de memória através dos <strong>MemObj</strong>.</p>  <p>Cada <strong>Memory Clerk </strong>é composto por uma série de alocações feitas pelo subcomponente chamado <strong>MemObj</strong>. Experimente rodar a query abaixo:</p>  <blockquote>   <p>select *      <br /> from sys.dm_os_memory_objects mo join      <br />&#160;&#160;&#160;&#160; sys.dm_os_memory_clerks mc      <br /> on mo.page_allocator_address = mc.page_allocator_address      <br /> where mc.type = 'MEMORYCLERK_SQLGENERAL'      <br /> order by pages_in_bytes desc</p> </blockquote>  <p>Na query exemplo, estamos procurando os MemObj responsáveis pelo alto consumo do Memory Clerk.</p>  <p>O resultado apresenta os principais subconsumidores de memória:</p>  <blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/8032.image_032BB192.png"><img title="image" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/0574.image_thumb_72B34096.png" width="580" height="174" /></a></p> </blockquote>  <p>Agora podemos afirmar com 100% de certeza que o principal responsável é o MEMOBJ_MSXML. Sim – o problema de Memory Leak foi causado pelo XML!   </p>
