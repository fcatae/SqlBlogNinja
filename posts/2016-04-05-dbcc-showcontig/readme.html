<a link='https://blogs.msdn.microsoft.com/fcatae/2016/04/05/dbcc-showcontig/'>DBCC SHOWCONTIG</a>
<p>Tudo come&ccedil;ou no artigo sobre <a href="http://blogs.msdn.com/b/fcatae/archive/2016/03/22/set-statistics-io.aspx">a vantagem de usar o SET STATISTICS IO</a> e depois falei sobre o <a href="http://blogs.msdn.com/b/fcatae/archive/2016/03/29/dbcc-dropcleanbuffers.aspx">uso correto do DBCC DROPCLEANBUFFERS</a> (existe uso correto?). Dessa vez vamos explorar o antigo companheiro DBCC SHOWCONTIG.<p>Vamos come&ccedil;ar analisando a query que demorava 1ms:</p><blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/3426.image_124B34D1.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/1121.image_thumb_225A0388.png" width="316" height="54"></a></p> </blockquote><p>Esse tempo de 1 milissegund era poss&iacute;vel porque todas os dados estavam previamente em mem&oacute;ria. Limpando o cache e rodando a query novamente, observamos que o tempo subia para 846ms.</p><blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/4846.image_4FDB234B.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/0576.image_thumb_763D0696.png" width="644" height="165"></a></p> </blockquote><p>As p&aacute;ginas foram carregadas usando o mecanismo de read-ahead e isso pode ser observado atrav&eacute;s da visualiza&ccedil;&atilde;o do Buffer Pool. Na figura abaixo, &eacute; percebe-se que algumas p&aacute;ginas foram carregadas no mesmo instante (veja a coluna read_microsec).</p><p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/5140.image_4615BBD3.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/1212.image_thumb_47E6119A.png" width="768" height="386"></a></p><p>Com base na figura anterior, observamos que h&aacute; conjuntos de p&aacute;ginas carregando em 57634 microssegundos, enquanto que outro conjunto carrega em 107984 microssegundos. Podemos inclusive verificar que as p&aacute;ginas 8728 a 8791 abrangem exatamente 64 p&aacute;ginas.</p><p>Esse comportamento ilustra bem a opera&ccedil;&atilde;o de &ldquo;read-ahead&rdquo;. Ao inv&eacute;s de requisitar ao storage as p&aacute;ginas individualmente, o SQL Server agregou as solicita&ccedil;&otilde;es em uma &uacute;nica requisi&ccedil;&atilde;o. Isso significa que o servidor enviou um &uacute;nico I/O de 512Kb ao inv&eacute;s de enviar 64 I/O de 8Kb.</p><p>Entretanto, resolvemos desligar temporariamente o read-ahead usando o Trace Flag 652.</p><p>Observamos que a query realizou leituras f&iacute;sicas e teve um aumento significativo no tempo de execu&ccedil;&atilde;o:</p><blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/8424.image_0982DE98.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/4572.image_thumb_18B94765.png" width="644" height="167"></a></p> </blockquote><p>Aquela mesma visualiza&ccedil;&atilde;o do Buffer Pool se modifica e as p&aacute;ginas s&atilde;o carregadas em tempos diferentes (coluna read_microsec). Os tempos de disco ficaram em torno de 1ms por p&aacute;gina.</p><p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/6242.image_018DCCE7.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/5775.image_thumb_1F6EE199.png" width="749" height="315"></a></p><p>Agora podemos fazer a matem&aacute;tica:</p><ul>   <li>O tempo de leitura da p&aacute;gina &eacute; de aproximadamente 1ms</li>    <li>Cada p&aacute;gina cont&eacute;m 8 registros (coluna row_count)</li>    <li>Portanto, conseguimos fazer a leitura de 8 registros/ms. </li> </ul><p>A tabela de 10.000 registros poder&aacute; ser lida em aproximadamente 1250ms.</p><p>&nbsp;</p><h3>DBCC SHOWCONTIG</h3><p>Ao longo do tempo, as opera&ccedil;&otilde;es de INSERT, DELETE e UPDATE causam buracos na tabela e fragmentam as p&aacute;ginas. O problema &eacute; que as tabelas podem crescer por conta da fragmenta&ccedil;&atilde;o!</p><p>Tenho certeza que aqueles da velha guarda v&atilde;o se lembrar do DBCC SHOWCONTIG. Sua sintaxe simplificada &eacute;:</p><blockquote>   <p>DBCC SHOWCONTIG(&lt;table&gt;)</p> </blockquote><blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/3005.image_3EB4191D.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/2352.image_thumb_2BFF1F66.png" width="489" height="224"></a></p> </blockquote><p>A an&aacute;lise n&atilde;o tem muito segredo: </p><ul>   <li>H&aacute; 1257 p&aacute;ginas agrupadas em 160 extents</li>    <li>H&aacute; aproximadamente 7,9 p&aacute;ginas por Extents (recomendado &eacute; 8)</li>    <li>Scan Density: 98,75% (quanto maior, melhor)</li>    <li>Avg Page Density: 79,88% (quanto maior, melhor)</li> </ul><p>O principal indicador de fragmenta&ccedil;&atilde;o &eacute; a &uacute;ltima linha &ldquo;Avg Page Density&rdquo;, que fala sobre o preenchimento da p&aacute;gina.</p><p>&nbsp;</p><h3>Fragmenta&ccedil;&atilde;o de Dados</h3><p>Rodamos o seguinte script para simular a fragmenta&ccedil;&atilde;o ao longo do tempo:</p><blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/4186.image_67528524.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/0385.image_thumb_3BA1BB28.png" width="334" height="107"></a></p> </blockquote><p>ANTES: Sem fragmenta&ccedil;&atilde;o.</p><blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/8662.image_28ECC171.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;margin: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/7245.image_thumb_122D79E8.png" width="489" height="224"></a></p> </blockquote><p>DEPOIS: Com fragmenta&ccedil;&atilde;o.</p><blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/1754.image_5433E929.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/0777.image_thumb_1D5994E3.png" width="485" height="220"></a></p> </blockquote><p>Reparamos que o Page Density despencou de 79,88% para apenas 42,49% de preenchimento. Isso reflete em um aumento do tempo da query, que estava em 1360ms, para 2437ms.</p><p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/5482.image_0AA49B2C.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/4784.image_thumb_53CA46E5.png" width="644" height="159"></a></p><p>&nbsp;</p><h3>Conclus&atilde;o</h3><p>Estamos conseguindo piorar o tempo da query a cada artigo! Dessa vez, for&ccedil;amos a fragmenta&ccedil;&atilde;o de dados para aumentar o tempo gasto acessando o disco. O diagn&oacute;stico foi feito usando o DBCC SHOWCONTIG.</p><p>Entretanto, desde o SQL Server 2005, o comando SHOWCONTIG foi substitu&iacute;do pela DMF sys.dm_db_index_physical_stats.</p><blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/7506.image_2ECC866C.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/2705.image_thumb_2E605377.png" width="683" height="41"></a></p> </blockquote><p>Existem enormes vantagens para usar essa nova sintaxe. </p><p>Para quem n&atilde;o se lembra, o comando DBCC SHOWCONTIG causava concorr&ecirc;ncia e bloqueios durante a sua execu&ccedil;&atilde;o, ficando quase que impratic&aacute;vel rodar em produ&ccedil;&atilde;o. A nova sintaxe permite especificar uma an&aacute;lise LIMITED ou SAMPLED ao inv&eacute;s de DETAILED. </p><p>No pr&oacute;ximo artigo, vamos falar sobre o DBCC PAGE e tentaremos piorar ainda mais o desempenho da nossa query.</p></p>

