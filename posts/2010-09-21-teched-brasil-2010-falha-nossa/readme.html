<a link='https://blogs.msdn.microsoft.com/fcatae/2010/09/21/teched-brasil-2010-falha-nossa/'>TechEd Brasil 2010 â€“ Falha Nossa</a>
<p>Eu e o Fabio Gentile apresentamos a palestra <strong>SUP403 - SQL Server com foco em Diagn&oacute;stico de Desempenho</strong>. Por ser o &uacute;ltimo hor&aacute;rio do &uacute;ltimo dia, decidimos manter a palestra no n&iacute;vel 300. Engra&ccedil;ado que, durante a fase de montagem da palestra, deparamos com algumas situa&ccedil;&otilde;es inusitadas e que poderiam ser classificadas como n&iacute;vel 400 (n&iacute;vel m&aacute;ximo):</p>
<ol>
<li>A primeira demonstra&ccedil;&atilde;o de alto consumo de CPU deixou a m&aacute;quina em um estado devagar quase parando. As queries realizavam opera&ccedil;&otilde;es de Table Scan com paralelismo e n&atilde;o sobrava recurso para o usu&aacute;rio. A solu&ccedil;&atilde;o foi diminuir a prioridade do processo <strong>SQLSERVR.EXE</strong> para <em><strong>Base Priority = Low</strong></em>. </li>
<li>Na mesma demonstra&ccedil;&atilde;o, um &iacute;ndice n&atilde;o-clustered seria criado para suportar a consulta e, assim, otimizar o consumo de recursos. A execu&ccedil;&atilde;o do comando CREATE INDEX j&aacute; passava de 9 minutos e n&atilde;o havia terminado. Atrav&eacute;s da DMV sys.dm_exec_requests, descobrimos que a cria&ccedil;&atilde;o de &iacute;ndice esperava por mem&oacute;ria (<strong>RESOURCE_SEMAPHORE</strong>). A solu&ccedil;&atilde;o foi diminuir o n&uacute;mero de clientes concorrentes e aumentar o par&acirc;metro &ldquo;<em>Max Server Memory</em>&rdquo; da inst&acirc;ncia SQL. Ap&oacute;s a mudan&ccedil;a, o &iacute;ndice foi criado em 17 segundos. </li>
<li>Tentamos criar um cen&aacute;rio em que uma Stored Procedure realizava uma grande quantidade de escritas em uma tabela. Quer&iacute;amos demonstrar as esperas pelo wait type WRITELOG, mas tudo o que se observava era <strong>PREEMPTIVE_OS_WRITEFILEGATHER</strong>. O problema estava relacionado com o fato de que o bloco de escrita (LogCache) era t&atilde;o grande que precisava ser quebrado em peda&ccedil;os menores. A solu&ccedil;&atilde;o foi evitar usar transa&ccedil;&otilde;es longas, intercalando com transa&ccedil;&otilde;es menores. </li>
<li>No mesmo cen&aacute;rio de inser&ccedil;&atilde;o de dados, a tabela usava campos INTEGER e CHAR(4000). Queria demonstrar as esperas pelo wait type WRITELOG, mas tudo o que observava era PAGEIOLATCH. A causa desse problema &eacute; que o gargalo estava nos <strong>Page Splits</strong> de dados e n&atilde;o nas opera&ccedil;&otilde;es de log. A solu&ccedil;&atilde;o foi substituir a coluna CHAR(4000) por outra INTEGER. Dessa forma, as p&aacute;ginas de dados armazenariam um maior n&uacute;mero de registros e ocorreria um menor n&uacute;mero de Page Splits. </li>
</ol>
<p>Da pr&oacute;xima vez, guarderei todas essas situa&ccedil;&otilde;es para fazer uma palestra que seja 100% n&iacute;vel 400.</p>
