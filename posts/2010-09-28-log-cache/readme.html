<a link='https://blogs.msdn.microsoft.com/fcatae/2010/09/28/log-cache/'>Log Cache</a>
<p>O <strong>Log Manager</strong> é responsável por todas as rotinas relacionadas com a escrita/leitura das informações no log. As informações são gravadas fisicamente em um arquivo de log. Um servidor SQL apresenta um <strong>Log Manager </strong>por banco de dados e pode ser monitorado através dos contadores do Performance Monitor:</p>  <p><em>SQLServer:Databases</em></p>  <ul>   <li>Log Bytes Flushed/sec - Quantidade de bytes gravados em disco </li>    <li>Log Flush Wait Time - Tempo de espera para a gravação em disco </li>    <li>Log Flushes/sec - Número de gravações (flushes) no arquivo de log </li> </ul>  <p>As gravações em disco são feitas usando blocos de memória denominados <strong>Log Cache </strong>- também chamado de LogTable, que é uma estrutura em memória utilizada para armazenar os registros instantes antes de serem escritos em discos. Durante o processo de gravação de registros, as threads realizam a escrita de registros no <strong>Log Cache </strong>e o <strong>Log Manager </strong>realiza a gravação efetiva em disco.</p>  <p>O processo de gravação em log é realizado em duas etapas:</p>  <ol>   <li>As threads utilizam uma rotina de gravação no <strong>Log Cache</strong>, que fica em memória, e espera pela gravação. Múltiplas threads podem inserir novos registros no arquivo de log simultaneamente, entretanto, o acesso ao <strong>Log Cache </strong>é serializado. Após gravar as informações no cache, a thread aguarda no wait stats = <em>WRITELOG</em>. </li>    <li>No instante seguinte, o processo de <strong>Log Manager </strong>correspondente do banco de dados processa o <strong>Log Cache </strong>ativo e realiza a gravação em disco. Quando os registros de log são gravados efetivamente em disco, o<strong> Log Manager</strong> sinaliza todas as threads que esperavam por <em>WRITELOG</em>. </li> </ol>  <p>No caso do TempDB, o Log Manager utiliza escritas assíncronas para evitar que as threads fiquem esperando pelo arquivo de log, uma vez que não existe processo de recovery do TempDB. Esse comportamento agiliza muito a performance das tabelas temporárias e, por isso, dificilmente observamos esperas por <em>WRITELOG </em>no TempDb.</p>
