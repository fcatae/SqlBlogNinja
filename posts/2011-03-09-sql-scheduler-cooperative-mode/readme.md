<a link='https://blogs.msdn.microsoft.com/fcatae/2011/03/09/sql-scheduler-cooperative-mode/'>SQL Scheduler: Cooperative Mode</a>
<p>Muitas pessoas ficam curiosas para saber o que significa o SQL Scheduler e qual o papel que ele desempenha. Por um tempo pensava que não valeria a pena ficar falando sobre esse componente, uma vez que ele é bastante interno. Por outro lado, esse é um conhecimento indispensável para àqueles que pretendem ler um Dump no SQL Server. O primeiro passo é diferenciar o modo multitarefa presente no Windows e SQL Server: <strong>Preemptive Mode </strong>e <strong>Cooperative Mode</strong>.</p>  <p>Relembrando os velhos tempos do Windows 3.1 e Windows 98:</p>  <ul>   <li><em><strong><u>Windows 98</u></strong> uses <strong><u>preemptive multitasking </u></strong>for Win32-based applications. This means that the operating system takes control away from or gives control to another running task, depending on the needs of the system. </em></li> </ul>  <p>Atualmente, o Windows e os Sistemas Operacionais modernos utilizam o <strong>Preemptive Mode</strong>: cada aplicação/thread recebe uma parcela de tempo (quantum) para ocupar o processamento disponível. Quando esse quantum é excedido (em torno de 10-100 milissegundos), o Sistema Operacional realiza a transição para a próxima aplicação/thread. Esse processo permite que as tarefas sejam realizadas simultaneamente, dando a impressão de paralelismo mesmo quando existe uma única unidade de CPU.</p>  <p>Abusando dos dons artísticos, seria como um relógio que determina qual será a tarefa executada: </p>  <blockquote>   <p><a href="images\0638.image_00DD8F8B.png"><img style="border-bottom: 0px;border-left: 0px;padding-left: 0px;padding-right: 0px;border-top: 0px;border-right: 0px;padding-top: 0px" title="Preemptive Scheduling" border="0" alt="Clock simulating a preemptive scheduling" src="images\3858.image_thumb_16E3FB1D.png" width="225" height="240" /></a>&#160;</p> </blockquote>  <p>Esse comportamento é diferente da versão antiga do Windows que ainda rodava no <strong>Cooperative Mode</strong>.</p>  <ul>   <li><em>With <strong><u>Windows 3.1</u></strong>, applications ran concurrently through a method known as <strong><u>cooperative multitasking</u></strong>. Using this method, the operating system required an application to check the message queue periodically and to relinquish control of the system to other running applications. Applications that did not check the message queue would effectively &quot;hog&quot; CPU time and prevent the user from switching to another application. For compatibility reasons, Windows 98 cooperatively multitasks Win16-based applications. </em></li> </ul>  <p>No tempo do Windows 3.1, as aplicações e o Sistema Operacional trabalhavam juntos para criar o multitasking das tarefas. Cada aplicação era responsável por fazer parte do seu processamento e manualmente repassar o controle de volta ao Windows. Era o processo de YIELD: na tradução literal seria algo como “dar a passagem”.</p>  <p>Novamente utilizando-me dos dons artísticos, o modo cooperativo seria similar a uma brincadeira de passa anel: cada tarefa vai passando o anel para o próximo do círculo.</p>  <blockquote>   <p><a href="images\6102.image_472ACFD3.png"><img style="border-bottom: 0px;border-left: 0px;padding-left: 0px;padding-right: 0px;border-top: 0px;border-right: 0px;padding-top: 0px" title="image" border="0" alt="image" src="images\5037.image_thumb_4C2D0D82.png" width="214" height="240" /></a></p> </blockquote>  <p>Encerro o artigo dizendo que o SQL Server, de forma similar ao Windows 3.1,&#160; implementa o Cooperative Mode para a execução de tarefas ao invés do Preemptive Mode. Isso pode parecer que voltamos no passado. </p>  <p>Existem problemas e desvantagens, isso é verdade… mas existe um forte motivo pelo qual se utiliza um gerenciamento próprio de thread: “<em>SQL knows better</em>” -&#160; SQL Server conhece mais sobre ele mesmo do que o Windows. Ao invés de depender do gerenciamento multithread do Sistema Operacional, utilizamos uma arquitetura mais adequada para garantir a escalabilidade do produto.</p>  <p>No próximo artigo, falaremos sobre o Scheduler.</p>
