<a link='https://blogs.msdn.microsoft.com/fcatae/2016/06/21/usando-o-index-scan-covered-index/'>Usando o Index Scan (Covered Index)</a>
<p>Acabei de escrever sobre os conceitos do Table Scan (<a href="https://blogs.msdn.microsoft.com/fcatae/2016/05/31/aprendi-sql-com-comandos-obsoletos/">Aprendi SQL com Comandos Antigos</a>), na qual ressalto a importância do Table Scan: retornar um grande número de registros de forma eficiente. Em seguida, comento sobre o <a href="https://blogs.msdn.microsoft.com/fcatae/2016/06/07/fim-do-table-scan/">Fim do Table Scan</a> – ou melhor, não há motivos para realizar IAM Scan em um banco de dados. O motivo é que o Index Scan é geralmente uma estratégia mais eficiente.</p> <p>Por exemplo, considere essa consulta:</p> <blockquote> <p>SELECT nome, sobrenome FROM tbPessoas</p></blockquote> <p>Como a consulta não tem filtro, o caminho óbvio é realizar o Table Scan da tabela e retornar todos os registros. Entretanto, podemos criar um índice para “cobrir a consulta” usando somente os campos “nome” e “sobrenome”</p> <blockquote> <p>CREATE INDEX coveredIndex ON tbPessoas <strong>( nome, sobrenome )</strong></p></blockquote> <p>É mais eficiente realizar um Index Scan sobre o “Covered Index” ao invés de fazer um Table Scan porque o índice é mais “magro” que uma tabela. Assim, podemos definir a estratégia de “covered index” como uma forma de reduzir o consumo de I/O.</p> <p>Um exemplo ligeiramente diferente seria quando um índice para auxiliar a contagem:</p> <blockquote> <p>SELECT COUNT(*) FROM tbPessoas WHERE nome LIKE N'F%';</p></blockquote> <p>A forma ineficiente para contar número de registros de uma tabela é através de um Table Scan. Por outro lado, poderíamos criar um índice sobre a coluna “nome” para facilitar a consulta, que usa esse índice para contar quantas pessoas começam com a letra “F”.</p> <blockquote> <p>CREATE INDEX index ON tbPessoas (nome)</p></blockquote> <p>Entretanto, vamos supor que, ao invés de contar, precisamos retornar o nome e sobrenome das pessoas:</p> <blockquote> <p>SELECT nome, sobrenome FROM tbPessoas WHERE nome LIKE N'F%'; </p></blockquote> <p>Nesse caso, o ideal é criar um índice que inclua nome e sobrenome:</p> <blockquote> <p>CREATE INDEX index ON tbPessoas ( nome , sobrenome )</p></blockquote> <p>&nbsp;</p> <h3>Ordem dos Campos </h3> <p>Uma pergunta comum é se a ordem dos campos do índice importa. A resposta é SIM.</p> <p>Em um índice tradicional, os dados são organizados em uma estrutura de dados denominada BTree (mais precisamente B+ Tree). Isso significa que os dados ficam ordenados pela primeira coluna e, em caso de empate, pela segunda coluna, depois pela terceira e assim por diante (se houver mais colunas). Por isso, os índices IDX1 e IDX2 ilustrados abaixo são diferentes:</p> <blockquote> <p>CREATE INDEX idx1 ON tbPessoas ( nome, sobrenome )</p> <p>CREATE INDEX idx2 ON tbPessoas ( sobrenome, nome )</p></blockquote> <p>O primeiro índice, idx1, está ordenado pela coluna “nome” e pode auxiliar as consultas que filtram pela coluna “nome”. O segundo índice, idx2, está ordenado por “sobrenome”. Por isso, cada tipo de consulta pode usar diferentes índices:</p> <blockquote> <p>SELECT COUNT(*) FROM tbPessoas WHERE nome = ‘Fabricio’ -- Usando o primeiro índice </p></blockquote> <p>Enquanto que:</p> <blockquote> <p>SELECT COUNT(*) FROM tbPessoas WHERE sobrenome = ‘Catae’ -- Vai pelo segundo índice </p></blockquote> <p>A regra é simples: somente as primeiras colunas são usadas para filtrar consultas, enquanto que as demais podem ser normalmente usadas para “cobrir a consulta”.</p> <p>Veja alguns exemplos:</p> <blockquote> <p>SELECT nome, email FROM tbPessoasl WHERE id = 1</p></blockquote> <p>Podemos criar um índice para filtrar “id = 1” ao mesmo tempo que cobrimos as colunas “nome” e “email”. Assim, o índice criado seria:</p> <blockquote> <p>CREATE INDEX idxEmail ON tbPessoas ( id , nome, email )</p></blockquote> <p>Esse índice (idxEmail) seria usado para filtrar qualquer consulta baseada no ID. Entretanto, ela poderia cobrir somente consultas que retornam id, nome ou email. Por exemplo:</p> <blockquote> <p>SELECT nome FROM tbPessoas WHERE id = 2</p> <p>SELECT email FROM tbPessoas WHERE id = 3</p> <p>SELECT id, nome, email FROM tbPessoas WHERE id = 4</p></blockquote> <p>&nbsp;</p> <h3>Sintaxe do INCLUDE</h3> <p>Como vimos anteriormente, quando criamos um índice a ordem dos campos importa para filtrar a consulta. </p> <p>Entretanto, a ordem dos campos não é importante para fazer a “cobertura da consulta”. Voltando ao exemplo inicial:</p> <blockquote> <p>SELECT nome, sobrenome FROM tbPessoas</p></blockquote> <p>Podemos criar um covered index sem nos preocupar com a ordem das colunas:</p> <blockquote> <p>CREATE INDEX coveredIndex ON tbPessoas <strong>( nome, sobrenome )</strong></p> <p>CREATE INDEX coveredIndex ON tbPessoas <strong>( sobrenome, nome )</strong></p></blockquote> <p>Quando estamos incluindo campos para cobertura de consulta e sem filtros associados, podemos usar a sintaxe INCLUDE e deixar a sintaxe explicita:</p> <blockquote> <p>CREATE INDEX coveredIndex ON tbPessoas (id) <strong>INCLUDE</strong>&nbsp;<strong>( sobrenome, nome )</strong></p></blockquote> <p>Estamos especificando que o índice poderá ser usado para filtrar a coluna “id” ao mesmo tempo que pode cobrir os campos de “id”, “nome”, “sobrenome”.</p> <p>&nbsp;</p> <p>Apesar do assunto ser fácil, o artigo ficou um pouco complicado. Por isso, se tiver dúvidas, não deixe de escrever um comentário. </p>
