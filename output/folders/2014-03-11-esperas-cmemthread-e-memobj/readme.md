<a link='https://blogs.msdn.microsoft.com/fcatae/2014/03/11/esperas-cmemthread-e-memobj/'>Esperas CMEMTHREAD e MemObj</a>
<p>Nos últimos posts, falamos sobre o <strong>Memory Clerk </strong>e o <strong>MemObj</strong>.</p>  <blockquote>   <p>Monitorando Memória com os Clerks     <br /><a title="http://blogs.msdn.com/b/fcatae/archive/2014/02/25/monitorando-memoria.aspx" href="http://blogs.msdn.com/b/fcatae/archive/2014/02/25/monitorando-memoria.aspx">http://blogs.msdn.com/b/fcatae/archive/2014/02/25/monitorando-memoria.aspx</a></p> </blockquote>  <blockquote>   <p>Usando os Memory Objects     <br /><a title="http://blogs.msdn.com/b/fcatae/archive/2014/03/05/memoria-memory-object.aspx" href="http://blogs.msdn.com/b/fcatae/archive/2014/03/05/memoria-memory-object.aspx">http://blogs.msdn.com/b/fcatae/archive/2014/03/05/memoria-memory-object.aspx</a></p> </blockquote>  <p>Nesse artigo vou utilizar um post do Bob Dorr sobre o CMemThread</p>  <blockquote>   <p>How It Works: CMemThread and Debugging Them     <br /><a title="http://blogs.msdn.com/b/psssql/archive/2012/12/20/how-it-works-cmemthread-and-debugging-them.aspx" href="http://blogs.msdn.com/b/psssql/archive/2012/12/20/how-it-works-cmemthread-and-debugging-them.aspx">http://blogs.msdn.com/b/psssql/archive/2012/12/20/how-it-works-cmemthread-and-debugging-them.aspx</a></p> </blockquote>    <h1>Operador <em>new</em></h1>  <p>O SQL Server, assim como grande parte dos programas escrito em C++, utiliza o operador <strong>new </strong>para criar objetos.</p>  <blockquote>   <p>obj = new CClass( );</p> </blockquote>  <p>Essa rotina é transformada em uma chamada a um objeto MemObj. Podemos dizer que esse comando é equivalente a:</p>  <blockquote>   <p>obj = memObj.AllocateMemory( sizeof(CClass) );</p>    <p>// Seguido pela chamada ao construtor da classe</p> </blockquote>  <p>Como cada MemObj pertence a uma classe de Memory Clerk (sempre assim), então é possível sumarizar o consumo total de memória usando a DMV sys.dm_os_memory_clerks. A muito grosso modo, podemos dizer que o Memory Clerk é o somatório de toda memória utilizada pelo MemObj.</p>    <h1>Memory Objects (MemObj)</h1>  <p>Existem objetos MemObj dedicados por sessão, objeto, processador, etc. Em outras palavras, o SQL Server utiliza uma grande quantidade de MemObj em seu processo. Quer confirmar? Rode o comando:</p>  <blockquote>   <p>select * from sys.dm_os_memory_objects</p> </blockquote>  <blockquote>   <p><a href="images\3660.image_49C07A44.png"><img title="image" border="0" alt="image" src="images\1588.image_thumb_26930F92.png" width="634" height="217" /></a>&#160;</p> </blockquote>  <p>Observe que foram retornados 686 MemObj diferentes! Os objetos MemObj utilizam “page allocators”, que são as interfaces de acesso ao Memory Clerk – semelhante a um proxy.</p>    <h1>Alocação de Memória Single-Threaded</h1>  <p>Apesar de existir múltiplos MemObj, há uma restrição de acesso em paralelo. Todos esses objetos são single-threaded e serializam a chamada de alocação por memória. Se um MemObj for compartilhado entre sessão, então observamos a “contenção por MemObj” e será visível ao administrador de sistema.</p>  <blockquote>   <p>select * from sys.dm_exec_requests</p> </blockquote>  <blockquote>   <p><a href="images\7776.image_516E0455.png"><img title="image" border="0" alt="image" src="images\0385.image_thumb_2146B992.png" width="371" height="160" /></a></p> </blockquote>  <p>No exemplo, observamos que uma das sessões está alocando memória (55), enquanto que há sessões esperando (56, 57, 58, 59, 60). </p>    <h1>Famoso CMEMTHREAD</h1>  <p>A origem do nome CMEMTHREAD é decorrente de um lock interno do SQL Server. Utilizando um dump de memória, podemos observar o problema em detalhe. Note que na linha 08 existe uma referência a CMemThread&lt;CMemObj&gt;.</p>  <blockquote>   <p><a href="images\5102.image_77D27851.png"><img title="image" border="0" alt="image" src="images\4075.image_thumb_6E0D10D9.png" width="335" height="295" /></a></p> </blockquote>  <p>Se fosse possível ler o código do SQL Server, então haveria algo assim: </p>  <blockquote>   <p><font face="Consolas">CMemThread&lt;CMemObj&gt;::Alloc( size )       <br />{        <br />&#160;&#160;&#160; if( inUse ) {        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; wait( CMEMTHREAD );        <br />&#160;&#160;&#160; }        <br />&#160;&#160;&#160; <br />&#160;&#160;&#160; latch_get ();        <br />&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; CMemObj.internal_allocate_memory (size);        <br />        <br />&#160;&#160;&#160; latch_release ();        <br />}</font></p> </blockquote>    <h1>Trace Flag 8048</h1>  <p>A chance de ocorrer uma contenção de memória no objeto MemObj é mínima, mas sempre existe a possibilidade de isso acontecer e impactar diretamente o desempenho da instância.</p>  <p>Existem 3 tipos de distribuição de MemObj: </p>  <ul>   <li>1 global</li>    <li>1 por NUMA Node</li>    <li>1 por CPU lógico</li> </ul>  <p>Uma forma de aliviar a contenção é criar objetos MemObj por CPU. Nesse caso, fica quase impossível haver concorrência de acesso. Esse comportamento é habilitado através do Trace Flag 8048.</p>  <blockquote>   <p>SQL Server 2008/2008 R2 on Newer Machines with More Than 8 CPUs Presented per NUMA Node May Need Trace Flag 8048     <br /><a href="http://blogs.msdn.com/b/psssql/archive/2011/09/01/sql-server-2008-2008-r2-on-newer-machines-with-more-than-8-cpus-presented-per-numa-node-may-need-trace-flag-8048.aspx"><u>http://blogs.msdn.com/b/psssql/archive/2011/09/01/sql-server-2008-2008-r2-on-newer-machines-with-more-than-8-cpus-presented-per-numa-node-may-need-trace-flag-8048.aspx</u></a></p></blockquote>
