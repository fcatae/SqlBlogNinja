<a link='https://blogs.msdn.microsoft.com/fcatae/2010/09/22/lab-analisando-ndices/'>LAB: Analisando √çndices</a>
<p><strong>Pr&oacute;xima tarefa:</strong> Colocar todos os artigos encontrados na pr&aacute;tica. Data prevista: <strong><span style="text-decoration: underline">Final de outubro/2010</span></strong>.</p>
<p><strong>Post original:</strong></p>
<p>A discuss&atilde;o come&ccedil;ou com um coment&aacute;rio do <a target="_blank" href="http://vladimir-magalhaes.spaces.live.com">Vladimir Magalh&atilde;es</a> no Twitter: como encontrar &iacute;ndices n&atilde;o utilizados ou pouco utilizados atrav&eacute;s das Dynamic Management Views (DMV). A teoria diz que a sys.dm_index_operational_stats seria a resposta para resolver esse problema. Uma busca r&aacute;pida no Bing retornou o seguinte artigo:</p>
<p>Retaining historical index usage statistics for SQL Server (2009)<br /><a href="http://www.mssqltips.com/tip.asp?tip=1749">http://www.mssqltips.com/tip.asp?tip=1749</a></p>
<p>Ser&aacute; que somente isso &eacute; uma an&aacute;lise suficiente?</p>
<p>O intuito desse "Lab Post" &eacute; receber feedbacks sobre qual seria a melhor forma de analisar os &iacute;ndices em um banco de dados. Fiquem a vontade para postar seus coment&aacute;rios - n&atilde;o haver&aacute; modera&ccedil;&atilde;o de coment&aacute;rios. </p>
<p><strong>[Atualiza&ccedil;&atilde;o 29/09]</strong></p>
<p><strong>1) Query m&aacute;gina</strong></p>
<p>Igor deixou um coment&aacute;rio intrigante, que existe "uma query m&aacute;gica sugerida pelo autor que d&aacute; uma estat&iacute;sca, ele diz que de o valro retornado for &gt; que 50.000 o &iacute;ndice compensa muito". Esse &eacute; uma &oacute;timo lugar para come&ccedil;ar, eu fico imaginando se &eacute; alguma coisa relacionada com Missing Index ou se &eacute; algum contador do operational stats (ou index usage stats).</p>
<p><strong>2) Informa&ccedil;&otilde;es em Tempo de Execu&ccedil;&atilde;o</strong></p>
<p>Vladmir comentou sobre os MISSING INDEX que est&atilde;o dispon&iacute;veis dentro do plano de execu&ccedil;&atilde;o. Outra forma de observar &eacute; atrav&eacute;s das DMV de Missing Index. O coment&aacute;rio ""As MSFT suggest that index advantage over 5000 re-evaluate and over 10000 consider creating it."" &eacute; igualmente intrigante.</p>
<p>Por fim, deixou relembrou que nem sempre o otimizador est&aacute; correto. <br />Existem casos que o Otimizador &eacute; incapaz de determinar os melhores &iacute;ndices, mas apenas um DBA experiente conseguiria realizar. Ou um bug, como por exemplo:</p>
<p><strong><a href="http://www.sqlskills.com/BLOGS/PAUL/post/Missing-index-DMVs-bug-that-could-cost-your-sanity.aspx">http://www.sqlskills.com/BLOGS/PAUL/post/Missing-index-DMVs-bug-that-could-cost-your-sanity.aspx</a></strong></p>
<p><strong>3) Detecting Overlapping Indexes in SQL Server 2005</strong></p>
<p><strong><a href="http://blogs.msdn.com/b/mssqlisv/archive/2007/06/29/detecting-overlapping-indexes-in-sql-server-2005.aspx">http://blogs.msdn.com/b/mssqlisv/archive/2007/06/29/detecting-overlapping-indexes-in-sql-server-2005.aspx</a></strong></p>
<p><strong>4) &Iacute;ndices e Fill-factor</strong></p>
<p>Uma pergunta curiosa &eacute; determinar o fill-factor de um &iacute;ndice. Vladmir passou o link que monitora os page split usando Extended Events (!!!!), escrito pelo Eladio Rincon. </p>
<p><strong><a href="http://msmvps.com/blogs/eladio_rincon/archive/2008/12/07/using-xevents-extended-events-in-sql-server-2008-to-detect-which-queries-are-causing-page-splits.aspx">http://msmvps.com/blogs/eladio_rincon/archive/2008/12/07/using-xevents-extended-events-in-sql-server-2008-to-detect-which-queries-are-causing-page-splits.aspx</a></strong></p>
<p><strong>5) Index Usage e Operational Stats</strong></p>
<p>Fabricio Lima compartilhou essa experi&ecirc;ncia:</p>
<p>"Possuo um &iacute;ndice em uma tabela com 50 milh&otilde;es de registros. Nessa tabela, tenho um campo de situacao que pode ser 0,1,2,3 ou 4. Sempre acompanhei esse &iacute;ndice e vi que tinha poucas utiliza&ccedil;&otilde;es at&eacute; que um dia resolvi excluir esse &iacute;ndice seguindo o racioc&iacute;nio de que o &iacute;ndice era muito pouco seletivo, a tabela &eacute; grande, o indice &eacute; bem pouco utilizado ent&atilde;o n&atilde;o valeria a pena manter o &iacute;ndice. Entretanto, existia uma query com um where situacao = 2 dentre outras restri&ccedil;&otilde;es. A tabela tinha apenas uns 1000 registros com situa&ccedil;&atilde;o = 2, por isso esse &iacute;ndice era muito eficiente para essa query. Assim, no inicio do m&ecirc;s quando essa query &eacute; utilizada v&aacute;rias vezes mas somente no inicio do m&ecirc;s, essa query me causou um problema de lentid&atilde;o muito grande no banco... Na mesma noite tive que recriar o &iacute;ndice."</p>
<p>Entendo, portanto, que as DMV refletem um estado imediato do sistema e podem n&atilde;o corresponder a forma como o sistema funciona ao longo do tempo.</p>
<p><strong>6) Usando o Transaction Log para determinar Page Splits</strong></p>
<p>Grande Laerte sugeriu usar a fun&ccedil;&atilde;o n&atilde;o-documentada fn_dblog() para determinar page splits. Por que n&atilde;o? :)</p>
<p><strong>[Atualiza&ccedil;&atilde;o: 13/Out/10 - Adicionando uma refer&ecirc;ncia da Kimberly]</strong></p>
<p>From: <a href="http://www.sqlmag.com/blogs/sql-server-questions-answered/sql-server-questions-answered/tabid/1977/entryid/68816/Default.aspx">http://www.sqlmag.com/blogs/sql-server-questions-answered/sql-server-questions-answered/tabid/1977/entryid/68816/Default.aspx</a></p>
<p style="padding-left: 30px"><em>I&rsquo;d also add that MOST cases where I see 40, 50 or 60+ indexes are because of:</em></p>
<p style="padding-left: 30px"><em>1) Indexes are being added without any single person watching over what&rsquo;s being done (there are too many cooks in the kitchen!)</em></p>
<p style="padding-left: 30px"><em>2) Index recommendations are being made by a variety of tools but no one is analyzing what&rsquo;s there before they approve (and create) the recommended indexes. </em></p>
<p style="padding-left: 30px"><em>Here&rsquo;s how I&rsquo;ll summarize my answer: start with a small number of indexes and then slowly (and iteratively) add indexes that are recommended but never add one without checking your existing indexes to see if you can consolidate or remove an existing index first. This is a bit more challenging and I&rsquo;ll write a few posts on this coming up soon! Here&rsquo;s a step by step process I like to follow (especially helpful for developers):</em></p>
<p style="padding-left: 30px"><em>1) Create an effective clustering key. To help you understand the factors that make up a good clustering key, see these posts:</em></p>
<p style="padding-left: 30px"><em>a. Changing the Definition of a Clustered Index: </em><a href="http://www.sqlmag.com/blogs/sql-server-questions-answered/sql-server-questions-answered/tabid/1977/entryid/12749/Default.aspx"><em>http://www.sqlmag.com/blogs/sql-server-questions-answered/sql-server-questions-answered/tabid/1977/entryid/12749/Default.aspx</em></a></p>
<p style="padding-left: 30px"><em>b. Isn&rsquo;t the Clustering Key Redundant: </em><a href="http://www.sqlmag.com/blogs/sql-server-questions-answered/sql-server-questions-answered/tabid/1977/entryid/12852/Isnt-the-Clustering-Key-Redundant.aspx"><em>http://www.sqlmag.com/blogs/sql-server-questions-answered/sql-server-questions-answered/tabid/1977/entryid/12852/Isnt-the-Clustering-Key-Redundant.aspx</em></a></p>
<p style="padding-left: 30px"><em>c. Where does that Clustering Key Go? </em><a href="http://www.sqlmag.com/blogs/sql-server-questions-answered/sql-server-questions-answered/tabid/1977/entryid/12837/Where-Does-the-Clustering-Key-Go.aspx"><em>http://www.sqlmag.com/blogs/sql-server-questions-answered/sql-server-questions-answered/tabid/1977/entryid/12837/Where-Does-the-Clustering-Key-Go.aspx</em></a></p>
<p style="padding-left: 30px"><em>d. What Happens If I Drop A Clustered Index? </em><a href="http://www.sqlmag.com/blogs/sql-server-questions-answered/sql-server-questions-answered/tabid/1977/entryid/12748/Default.aspx"><em>http://www.sqlmag.com/blogs/sql-server-questions-answered/sql-server-questions-answered/tabid/1977/entryid/12748/Default.aspx</em></a></p>
<p style="padding-left: 30px"><em>2) Create your primary key (if it&rsquo;s not the clustering key and it&rsquo;s not always wise to make the primary key clustered)</em></p>
<p style="padding-left: 30px"><em>3) Create your unique keys</em></p>
<p style="padding-left: 30px"><em>4) Add foreign keys as appropriate and then manually create nonclustered indexes on your foreign keys. SQL Server has NEVER automatically created indexes on foreign keys and these can help in a number of ways. They can help improve the performance of the relationship as well as some joins. There are often better indexes for many joins but this is always a good way to start.</em></p>
<p style="padding-left: 30px"><em>5) Then, add a few nonclustered indexes for the columns that are very selective and used frequently in queries. A good example is LastName, FirstName, MiddleInitial. If you&rsquo;re doing a lot of customer lookups by name, then a single index which combines the columns in the order of what&rsquo;s most requested &ndash; can be added. If the combination is highly selective, SQL Server can use this index to help navigate to the data faster. If the column or combination of columns is not highly selective then the index is not as likely to be used (when the query is requesting other columns of data). This is where things start to get more challenging and we&rsquo;ll have to tackle these issues in another post. This is a good start. Do not add too many indexes&hellip;</em></p>
<p style="padding-left: 30px"><em>6) Slowly and iteratively add only the most important and critical indexes based on workload analysis. More coming up on this too!</em></p>
