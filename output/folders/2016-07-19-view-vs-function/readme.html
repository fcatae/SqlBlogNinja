<a link='https://blogs.msdn.microsoft.com/fcatae/2016/07/19/view-vs-function/'>View vs Function</a>
<p>No artigo anterior, fiz uma <a href="https://blogs.msdn.microsoft.com/fcatae/2016/07/12/tabelas-views-cte-e-synonyms">breve introdução sobre Views</a> e comentei que não há diferença de desempenho em usar Tabela, View ou CTE.</p> <p>Agora vamos criar uma View e uma Function para fazer a comparação. Note que a sintaxe do CREATE FUNCTION é um pouco mais extensa, pois define o tipo de dado a ser retornado e depois retorna um comando SELECT. Essa é uma FUNCTION do tipo “Single Statement”.</p> <p><a href="https://msdnshared.blob.core.windows.net/media/2016/06/image369.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/2016/06/image_thumb264.png" width="349" height="130"></a></p> <p><a href="https://msdnshared.blob.core.windows.net/media/2016/06/image370.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/2016/06/image_thumb265.png" width="349" height="179"></a></p>  <p>Se consultarmos a DMV sys.dm_exec_cached_plans, observamos que ambos são armazenados como Parse Tree – isso significa que representam apenas uma definição. Portanto, o desempenho entre Function <u>Single-Statement</u> é igual a uma Tabela, View ou CTE. </p> <p>&nbsp;</p> <h3>Multi-Statement Functions</h3> <p>Usar FUNCTION ao invés de VIEW traz um grande benefício: a flexibilidade em seu uso. Podemos compor múltiplos comandos para retornar os registros. A sintaxe é composta por dois blocos:</p> <ol> <li>Definição da tabela de retorno (@tb)</li> <li>Bloco composto por um ou mais comandos (BEGIN.. END)</li></ol> <p><a href="https://msdnshared.blob.core.windows.net/media/2016/06/image371.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/2016/06/image_thumb266.png" width="508" height="283"></a></p> <p>Vamos começar vendo a DMV sys.dm_exec_cached_plans, que mostra a função sendo representada por um “Compiled Plan – Proc”. </p> <p><a href="https://msdnshared.blob.core.windows.net/media/2016/06/image372.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/2016/06/image_thumb267.png" width="191" height="57"></a></p> <ul> <li>Function Single-statement é uma definição: representado por “parser tree”</li> <li>Function Multi-statement é um contexto de execução: representado por “compiled plan”</li></ul> <p>Isso significa que, por baixo dos panos, existe uma diferença significativa entre uma FUNCTION Single-statement e Multi-statement. Uma diferença clara está no plano de execução de consultas usando essas funções. Primeiro, vamos usar uma FUNCTION single-statement, que retorna um único plano de execução:</p> <p><a href="https://msdnshared.blob.core.windows.net/media/2016/06/image373.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/2016/06/image_thumb268.png" width="580" height="179"></a></p> <p>Por outro lado, uma FUNCTION multiple-statement tem seu próprio contexto de execução e executa separadamente do contexto do SELECT. Isso é observado no plano de execução, que é composto por dois planos de execução: query 1 corresponde ao SELECT; query 2 corresponde à FUNCTION. </p> <p><a href="https://msdnshared.blob.core.windows.net/media/2016/06/image374.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/2016/06/image_thumb269.png" width="592" height="495"></a></p> <p>Por causa desse comportamento de múltiplos contextos, as FUNCTION Multi-statement são geralmente menos eficientes em relação às FUNCTION Single-statement (e views, CTE, tabelas).</p> <p>&nbsp;</p> <h3>Predicate Push-Down</h3> <p>&nbsp;</p> <p>Predicate Push-Down é uma otimização do SQL Server, na qual a query é reescrita com os filtros aplicados às tabelas. Por exemplo, quem está acostumado com programação procedural (C++, C#, Java, etc), poderia pensar que a consulta a seguir executa a função fnUsuarios() e depois realiza os filtros de id = 1 e nome = b.</p> <p><a href="https://msdnshared.blob.core.windows.net/media/2016/06/image375.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/2016/06/image_thumb270.png" width="429" height="46"></a></p> <p>Entretanto, a otimização do “predicate push-down” empurra os filtro “id=1 and nome = b” para dentro da função fnUsuarios. Isso significa que a função fnUsuarios executaria o seguinte comando:</p> <p><a href="https://msdnshared.blob.core.windows.net/media/2016/06/image376.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/2016/06/image_thumb271.png" width="413" height="226"></a></p> <p>(Note que esse comando acima é fictício apenas para ilustrar o predicate push-down) Por conta da otimização, a função usa os índices disponíveis para retornar somente os registros que satisfazem ID e NOME</p> <p>Essa otimização ocorre no momento em que as Parse Trees são convertidas em um Compile Plan de execução. Por causa disso, não é possível aplicar a otimização de Predicate Push-Down em contexto de execuções distintos, como é o caso do SELECT com FUNCTION Multi-statement. Por outro lado, o predicate push-down ocorre naturalmente em todas as consultas SELECT, sub-SELECT, assim como também se aplica a Views, CTE e Function Single-statement. </p> <p>&nbsp;</p> <h3>Conclusão</h3> <p>Analisando o plano de execução de fnUsuariosMulti, observamos que todos os registros são inseridos na tabela @tb (Query 2) e depois o comando SELECT filtra os resultados desejados (Query 1). Nesse caso, nenhum índice é utilizado. Em nenhum momento, os índices são utilizados para acelerar a consulta.</p> <p><a href="https://msdnshared.blob.core.windows.net/media/2016/06/image377.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;margin: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/2016/06/image_thumb272.png" width="592" height="492"></a></p> <p>Se a função fnUsuariosMulti fosse substituída por uma View ou uma Function Single-statement, então o otimizador conseguiria agregar todas as Parse Trees em uma e depois a converteria em um Compiled Plan único. Nesse momento, a otimização de Predicate Push-Down seria aplicado diretamente à tabela e um índice seria usado para acessar os dados. O plano final se reduziria a um simples Clustered Index Seek:</p> <p><a href="https://msdnshared.blob.core.windows.net/media/2016/06/image378.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;margin: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/2016/06/image_thumb273.png" width="580" height="178"></a></p> <p>&nbsp;</p> <p>No próximo artigo, gostaria de propor um desafio. Existe um erro muito comum de programação que impacta diretamente na performance. Será que você consegue resolver? [Spoiler alarm] Adianto que a solução é simples: use Views. </p>
