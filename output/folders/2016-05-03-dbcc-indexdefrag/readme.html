<a link='https://blogs.msdn.microsoft.com/fcatae/2016/05/03/dbcc-indexdefrag/'>DBCC INDEXDEFRAG</a>
<p>Esse &eacute; mais um artigo da s&eacute;rie &ldquo;Saga da otimiza&ccedil;&atilde;o com comandos antigos&rdquo;<ul>   <li>Parte 1: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/03/22/set-statistics-io.aspx">SET STATISTICS IO</a> </li>    <li>Parte 2: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/03/29/dbcc-dropcleanbuffers.aspx">DBCC DROPCLEANBUFFERS</a> </li>    <li>Parte 3: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/04/05/dbcc-showcontig.aspx">DBCC SHOWCONTIG</a> </li>    <li>Parte 4: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/04/12/dbcc-page.aspx">DBCC PAGE</a> </li>    <li>Parte 5: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/04/19/sp-spaceused.aspx">sp_spaceused</a></li>    <li>Parte 6: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/04/26/dbcc-ind.aspx">DBCC IND</a> </li> </ul><p>No &uacute;ltimo artigo, falei sobre <a href="http://blogs.msdn.com/b/fcatae/archive/2016/04/26/dbcc-ind.aspx">a forma mais r&aacute;pida de executar um scan</a>. Nesse artigo vou falar sobre o INDEX SCAN. </p><p>Seria ele mais r&aacute;pido que o HEAP SCAN do artigo anterior? </p><p>Vamos come&ccedil;ar colocando ordem na heap!</p><h3>Heap &eacute; Desorganizada</h3><p>Heap scan &eacute; uma t&eacute;cnica muito r&aacute;pida porque favorece o uso das opera&ccedil;&otilde;es de read-ahead. </p><p>Entretanto, imagine o que acontece quando sabemos que a query retorna apenas um registro:</p><blockquote>   <p><strong>SELECT * FROM produtos WHERE id = 1234</strong></p> </blockquote><p>Isso poderia ser reescrito assim:</p><blockquote>   <p><strong>SELECT TOP(1) * FROM produtos WHERE id = 1234</strong></p> </blockquote><p>A primeira query realiza a leitura da tabela inteira para retornar todos os produtos com ID = 1234 e o comando faz a leitura de todos os registros para se certificar que, de fato, existe apenas um registro. Por outro lado, a segunda query usa <strong>TOP(1)</strong> para notificar que &eacute; necess&aacute;rio apenas um registro. Assim, o comando realiza o scan de tabela e finaliza logo que encontrar o primeiro registro. Estatisticamente, podemos dizer que a segunda query executa na metade do tempo da primeira.</p><p>Conclu&iacute;mos que a heap &eacute; um conjunto desorganizado de p&aacute;gina de dados, ou seja, a &uacute;nica forma de acesso &eacute; atrav&eacute;s do Heap Scan. Uma das formas de tornar o acesso mais r&aacute;pido &eacute; usando o TOP(n) para encerrar o scan o mais r&aacute;pido poss&iacute;vel.</p><h3>Heap Organizada</h3><p>Existe uma forma de tornar a Heap mais eficiente: ordenando os registros nas p&aacute;ginas de dados.</p><p>Heap: dados desorganizados &ndash; ser&aacute; que existe o ID = 1234? onde?</p><blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/3404.image_7CAE003A.png"><img title="image" style="border-left-width: 0px;border-right-width: 0px;border-bottom-width: 0px;padding-top: 0px;padding-left: 0px;margin: 0px;padding-right: 0px;border-top-width: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/8311.image_thumb_6C358F3F.png" width="244" height="192"></a></p> </blockquote><p>Heap Organizada: &eacute; f&aacute;cil de encontrar o ID = 1234.</p><blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/6076.image_1BF337BF.png"><img title="image" style="border-left-width: 0px;border-right-width: 0px;border-bottom-width: 0px;padding-top: 0px;padding-left: 0px;margin: 0px;padding-right: 0px;border-top-width: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/2620.image_thumb_223A0E4D.png" width="244" height="193"></a></p> </blockquote><p>Tornar a heap organizada &eacute; f&aacute;cil! Basta transformar a Heap em uma <strong>Tabela com Clustered Index</strong>.</p><h3>Clustered Index</h3><p>Clustered Index. Sim, esse &eacute; o nome de uma Heap Organizada. </p><blockquote>   <p>Infelizmente n&atilde;o gosto desse nome porque muita gente considera o Clustered Index mais como &iacute;ndice ao inv&eacute;s de Tabela. &Iacute;ndice &eacute; uma estrutura para ajudar o desempenho do banco de dados e voc&ecirc; pode criar v&aacute;rios na mesma tabela (10, 20, 30..). Entretanto, o Clustered Index &eacute; especial e voc&ecirc; s&oacute; pode criar um porque ele &eacute; a pr&oacute;pria tabela! N&atilde;o h&aacute; como organizar a Heap de duas formas diferentes ao mesmo tempo.</p> </blockquote><p>Clustered index organiza as p&aacute;ginas da tabela. A forma mais f&aacute;cil de enxergar isso &eacute; atrav&eacute;s do comando DBCC IND. Vamos investigar o index_id = 1, que corresponde ao &iacute;ndice clustered.</p><blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/3704.image_66E9393F.png"><img title="image" style="border-left-width: 0px;border-right-width: 0px;border-bottom-width: 0px;padding-top: 0px;padding-left: 0px;padding-right: 0px;border-top-width: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/0880.image_thumb_4D150310.png" width="570" height="311"></a></p> </blockquote><p>A p&aacute;gina 1:549 aponta para a pr&oacute;xima p&aacute;gina next_id = 1:548 e anterior prev_id = 1:550. Podemos investigar a p&aacute;gina anterior 1:550, que aponta para as p&aacute;ginas 1:549 e 1:551. Aqui &eacute; poss&iacute;vel ver que a primeira p&aacute;gina da tabela &eacute; a 1:557, pois ela n&atilde;o possui um ponteiro para a p&aacute;gina anterior.</p><p>&nbsp;</p><h3>Desorganizando o Clustered Index</h3><p>Sempre que realizamos uma opera&ccedil;&atilde;o de Table Scan em uma tabela com &iacute;ndice clustered, dizemos que:</p><blockquote>   <p>Table Scan = Clustered Index Scan</p> </blockquote><p>Em geral o desempenho do Clustered index scan &eacute; compar&aacute;vel com o Heap scan. O motivo &eacute; que as p&aacute;ginas est&atilde;o organizadas e fica f&aacute;cil de encontrar as informa&ccedil;&otilde;es. Entretanto, existe uma forma de bagun&ccedil;ar o local onde os dados est&atilde;o fisicamente armazenados: basta fragmentar a tabela e come&ccedil;ar a distribuir os dados em diferentes p&aacute;ginas.</p><p>Primeiro vamos criar uma tabela e adicionar a ordena&ccedil;&atilde;o com &iacute;ndice clustered:</p><blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/3175.image_18773786.png"><img title="image" style="border-left-width: 0px;border-right-width: 0px;border-bottom-width: 0px;padding-top: 0px;padding-left: 0px;padding-right: 0px;border-top-width: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/5857.image_thumb_1AB3C042.png" width="408" height="153"></a></p> </blockquote><p>Em seguida, adicionamos os produtos sem uma ordem espec&iacute;fica. </p><blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/1462.image_75B5FFC8.png"><img title="image" style="border-left-width: 0px;border-right-width: 0px;border-bottom-width: 0px;padding-top: 0px;padding-left: 0px;padding-right: 0px;border-top-width: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/0447.image_thumb_70D34C0C.png" width="327" height="151"></a></p> </blockquote><p>O resultado do DBCC IND mostra claramente que as p&aacute;ginas anteriores e posteriores est&atilde;o completamente fora de ordem.</p><blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/2500.image_12BEAE91.png"><img title="image" style="border-left-width: 0px;border-right-width: 0px;border-bottom-width: 0px;padding-top: 0px;padding-left: 0px;padding-right: 0px;border-top-width: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/5287.image_thumb_02B2708B.png" width="528" height="303"></a></p> </blockquote><p>Como as p&aacute;ginas est&atilde;o desordenadas, Clustered Index Scan n&atilde;o consegue executar transformar as opera&ccedil;&otilde;es de leitura em opera&ccedil;&otilde;es de read-ahead. </p><p>Isso torna o acesso ao &iacute;ndice mais lento. Como resolver? Basta desfragmentar o &iacute;ndice. No passado, usava-se bastante o comando DBCC INDEXDEFRAG. Hoje n&atilde;o h&aacute; motivo para usar o INDEXDEFRAG, pois se tornou obsoleto. Ao inv&eacute;s disso, procure usar a sintaxe do ALTER INDEX REORGANIZE que possui mais flexibilidade e suporte a parti&ccedil;&otilde;es.</p><blockquote>   <p><strong>ALTER INDEX nome_indice ON produtos REORGANIZE</strong></p> </blockquote><blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/6523.image_5FF138CD.png"><img title="image" style="border-left-width: 0px;border-right-width: 0px;border-bottom-width: 0px;padding-top: 0px;padding-left: 0px;padding-right: 0px;border-top-width: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/0184.image_thumb_3D300110.png" width="484" height="298"></a></p> </blockquote><p>Pronto! Agora o clustered index scan &eacute; praticamente t&atilde;o r&aacute;pido quanto heap scan e deixa a tabela organizada.</p><h3>Conclus&atilde;o</h3><p>&Eacute; recomendado organizar os dados da tabela usando um &iacute;ndice clustered. </p><p>Nesse artigo comentei que o desempenho Clustered Index scan &eacute; igual ao Heap scan ou inferior (quando o &iacute;ndice se encontra fragmentado). Portanto, criar um &iacute;ndice clustered sem qualquer estudo pode causar degrada&ccedil;&atilde;o de performance. </p><blockquote>   <p><strong>Criar um clustered index incorreto &eacute; pior do que n&atilde;o te-lo.</strong></p> </blockquote><p>No pr&oacute;ximo artigo vamos explorar um pouco mais a estrutura do &iacute;ndice, tamb&eacute;m conhecida por BTree+.</p></p>

