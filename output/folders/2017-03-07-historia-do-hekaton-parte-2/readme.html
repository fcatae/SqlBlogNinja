<a link='https://blogs.msdn.microsoft.com/fcatae/2017/03/07/historia-do-hekaton-parte-2/'>A História do Hekaton – Parte 2</a>
<table cellspacing="5" cellpadding="2" border="1"> <tbody> <tr> <td valign="top">Originalmente publicado no Lab27: <a title="http://www.lab27.com.br/a-histria-do-hekaton-parte-2/" href="http://www.lab27.com.br/a-histria-do-hekaton-parte-2/">http://www.lab27.com.br/a-histria-do-hekaton-parte-2/</a></td></tr></tbody></table>&nbsp; <p>No <a href="https://blogs.msdn.microsoft.com/fcatae/2017/03/06/historia-do-hekaton-parte-1/">post anterior</a>, comentei sobre as motivações que levaram à criação do Hekaton.  <p>O passo seguinte era transformar o projeto embrionário em uma implementação comercial, ou seja, incorporá-lo à família do SQL Server.  <h3>Compilação de Stored Procedures: .NET ou C/C++</h3> <p>Se a tradução de Stored procedure é procedimento armazenado, então porque não deixar o código de uma procedure previamente compilado em modo nativo? O primeiro passo para otimizar o desempenho transacional é eliminar a linguagem interpretada. Esse problema estava parcialmente resolvido através do uso de <a href="https://msdn.microsoft.com/en-us/library/ms131094.aspx">Stored Procedures em CLR</a>.  <p>A plataforma .NET oferece um recurso muito interessante chamado de “hosting”, que permite hospedar assemblies .NET dentro do processo e controlar o número de threads e consumo de memória. Você já deve ter se deparado com os latches <a href="http://blogs.msdn.com/b/psssql/archive/2008/12/02/how-it-works-what-is-behind-the-sqlclr-wait-category-in-sql-server-2008-activity-monitor.aspx">CLR_AUTO_EVENT e CLR_MANUAL_EVENT nas DMV</a>. Eles possuem uma série de funcionalidades e uma delas é o controle das threads de Garbage Collector e Finalizer pelo Engine do SQL Server.  <p>A questão é que as <a href="https://msdn.microsoft.com/en-us/library/ms131094.aspx">Stored Procedures em CLR</a> permitem substituir quase todos os comandos T-SQL (IF, WHILE, DECLARE, etc), mas não é possível compilar as queries. As queries devem ser executadas através de uma conexão de loopback chamada <a href="https://msdn.microsoft.com/en-us/library/microsoft.sqlserver.server.sqlcontext(v=vs.110).aspx">SqlContext</a>. Portanto, o desafio do Hekaton era converter queries (SELECT, INSERT, UPDATE, DELETE) em código nativo.  <p>A grande dificuldade era manter o Garbage Collector rodando em background sem afetar o desempenho do SQL Server. A equipe do Hekaton tentou a todo custo eliminar os latches associados à limpeza de memória, assim como enfrentava problemas específicos do .NET (Ex: descarregar os Assemblies dos AppDomains). Quem quiser entender mais sobre o ambiente do .NET Hosting, recomendo a leitura do livro:  <blockquote> <p>Customizing the Microsoft .NET Framework Common Language Runtime<br><a href="https://www.microsoft.com/learning/en-us/book.aspx?id=6895">https://www.microsoft.com/learning/en-us/book.aspx?id=6895</a></p></blockquote> <p>Ao final, a decisão foi utilizar um compilador C (sim, a linguagem C e não C++). Nesse caso, o SQL Server realiza a tradução do plano de execução em um arquivo .c e depois chama o compilador CL.EXE.  <p><a href="http://lab27.blob.core.windows.net/wordpress/2015/03/image.png"><img title="image" border="0" alt="image" src="http://lab27.blob.core.windows.net/wordpress/2015/03/image_thumb.png" width="278" height="377"></a>  <p>Sabendo que a linguagem C é mais rápida que a versão em .NET, por que a equipe do Hekaton não escolheu esse mecanismo logo de início? A resposta é segurança. Enquanto uma procedure em .NET pode ser gerada por um “emitter” em memória, a versão equivalente em C requer a criação de um código-fonte no File System e a compilação em uma DLL. Do ponto de vista de segurança, foi necessário blindar todos os tipos de ataque que mudem os arquivos .c ou .dll. Vários cenários foram levados em consideração para evitar furos de segurança. Por exemplo, imagine um hacker tentando alterar os arquivos de backup e mudando os arquivos C ou DLL. No caso do SQL Server, as stored procedures compiladas são sempre recriadas.  <h3>Árvores Bw-Trees</h3> <p>O desenho inicial do Hekaton incluia somente índices Hash. Essas estruturas são excelentes para consultas do tipo “chave-valor”, similar aos bancos de dados NoSQL. Entretanto, frequentemente encontramos expressões de desigualdade.  <p>Por exemplo:  <blockquote> <p><strong>data &gt; GETDATE()</strong>.</p></blockquote> <p>Nesse caso, não era possível obter ganhos de desempenho apenas com os índices Hash. Por volta de 2013, uma nova estrutura de dados, chamada Bw-tree, apareceu para resolver esse tipo de problema. Existe um paper que descreve bem o mecanismo, mas é um tanto complicado de entender todo o formalismo: <a href="http://research.microsoft.com/pubs/178758/bw-tree-icde2013-final.pdf">The Bw-Tree- A B-tree for New Hardware Platforms</a>.  <p>Se você quiser uma versão resumida do que é a nova Bw-Tree usada no Hekaton comparada com a tradicional B+ Tree, então diria que as modificações são feitas através de “delta updates” ao invés de “in-place updates”.  <p>Falarei mais sobre isso e sobre o formato dos arquivos no próximo post. Aguardem!
