<a link='https://blogs.msdn.microsoft.com/fcatae/2016/05/24/set-showplan_text/'>SET SHOWPLAN_TEXT</a>
<p>Esse &eacute; mais um artigo da s&eacute;rie &ldquo;Saga da otimiza&ccedil;&atilde;o com comandos antigos&rdquo;<ul>   <li>Parte 1: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/03/22/set-statistics-io.aspx">SET STATISTICS IO</a></li>    <li>Parte 2: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/03/29/dbcc-dropcleanbuffers.aspx">DBCC DROPCLEANBUFFERS</a></li>    <li>Parte 3: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/04/05/dbcc-showcontig.aspx">DBCC SHOWCONTIG</a></li>    <li>Parte 4: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/04/12/dbcc-page.aspx">DBCC PAGE</a></li>    <li>Parte 5: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/04/19/sp-spaceused.aspx">sp_spaceused</a></li>    <li>Parte 6: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/04/26/dbcc-ind.aspx">DBCC IND</a></li>    <li>Parte 7: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/05/03/dbcc-indexdefrag.aspx">DBCC INDEXDEFRAG</a></li>    <li>Parte 8: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/05/10/dbcc-dbreindex.aspx">DBCC DBREINDEX</a></li>    <li>Parte 9: <a href="http://blogs.msdn.com/b/fcatae/archive/2016/05/17/sp-detach-db.aspx">sp_detach_db</a></li> </ul><p>No &uacute;ltimo artigo, falamos do <a href="http://blogs.msdn.com/b/fcatae/archive/2016/05/17/sp-detach-db.aspx">impacto do storage em opera&ccedil;&otilde;es de Table Scan</a>. Agora &eacute; hora de resolver rapidamente usando &iacute;ndice.</p><h3>Criando &iacute;ndices</h3><p>Primeiro, vamos habilitar um comando antigo chamado SHOWPLAN_TEXT.</p><blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/0167.image_15BDE667.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/0285.image_thumb_308A0C73.png" width="310" height="124"></a></p> </blockquote><p>Embora haja comandos melhores, o SHOWPLAN_TEXT possui um resultado texto f&aacute;cil para entender.</p><p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/0447.image_4098DB2A.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/0184.image_thumb_224E2434.png" width="644" height="132"></a></p><p>Na primeira linha temos o comando original e na segunda, o plano de execu&ccedil;&atilde;o. </p><p>A solu&ccedil;&atilde;o para o problema de desempenho &eacute; criar um &iacute;ndice.</p><blockquote>   <p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/0882.image_4AEC903B.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/0363.image_thumb_5448556F.png" width="244" height="40"></a></p> </blockquote><p>Agora nosso comando ter&aacute; um novo plano de execu&ccedil;&atilde;o:</p><p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/6404.image_087C7EB6.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/0160.image_thumb_0EC35544.png" width="644" height="85"></a></p><p>Por que esse plano &eacute; melhor? Simples. Basta contar o n&uacute;mero de I/O em disco.</p><p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/5670.image_5A2589B9.png"><img title="image" style="border-top: 0px;border-right: 0px;border-bottom: 0px;padding-top: 0px;padding-left: 0px;border-left: 0px;padding-right: 0px" border="0" alt="image" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/28/29/metablogapi/7444.image_thumb_1578EF78.png" width="644" height="90"></a></p><p>Se tivermos lat&ecirc;ncias de 5ms, ent&atilde;o a query demora aproximadamente 15ms. Entretanto, se o storage apresentar lentid&atilde;o e a lat&ecirc;ncia subir para 100ms (muito ruim), a query executa em apenas 300ms (menos que 1 segundo). </p></p>

